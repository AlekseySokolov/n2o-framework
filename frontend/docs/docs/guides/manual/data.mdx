---
title: Провайдеры данных
description: ""
---
import { Sandbox } from '../../../src/components/Sandbox/Sandbox'

В N2O Framework визуальные компоненты связываются с данными через объекты и выборки.
Объекты и выборки делегируют свои вызовы провайдерам данных.

Провайдеры — это универсальный способ обращения к источнику или к сервису предоставляющему данные.
N2O поддерживает провайдеры SQL, REST, GraphQl, Spring Beans, EJB, MongoDB и другие.

![](./images/data-f1687.png)

### Объект {#Object}

Объект — это сущность предметной области.
Он объединяет в себе все операции над этой сущностью и её валидации.

Объекты создаются с помощью файлов `[id].object.xml`.

```xml
<?xml version='1.0' encoding='UTF-8'?>
<object xmlns="http://n2oapp.net/framework/config/schema/object-4.0"
  name="Мой объект">
  <fields>
    <!-- Поля объекта -->
    <field id="id"/>
    <field id="name"/>
    <field id="birthday"/>
    <list id="docs">...</list>
    ...
  </fields>
  <operations>
    <!-- Операции объекта -->
    <operation id="create">...</operation>
    <operation id="update">...</operation>
    <operation id="delete">...</operation>
    ...
  </operations>
  <validations>
    <!-- Валидации объекта -->
    <constraint id="uniqueName">...</constraint>
    <condition id="dateInPast">...</condition>
    ...
  </validations>
</object>
```

[Подробнее об объектах](../xml/object)

#### Операции объекта {#Object_operations}

Над объектом можно выполнять операции, например, создание или удаление.
Операция определяет входные, выходные данные для [провайдера](#Data_providers) и задаёт список валидаций.

```xml title="Операция объекта"
<operation id="create">
  <invocation>
    ... <!--Провайдер данных-->
  </invocation>
  <in>
      <!--Входные данные-->
      <field id="name"/>
      <field id="birthday"/>
  </in>
  <out>
      <!--Выходные данные-->
      <field id="id"/>
  </out>
  <fail-out>
      <!--Выходные данные в случае ошибки операции-->
      <field id="message" mapping="#this.getMessage()"/>
  </fail-out>
  <validations>...</validations><!--Валидации операций-->
</operation>
```

<Sandbox height={200} projectId="data_object_operations" />

#### Валидации объекта {#Object_validations}

Валидации — это проверки объекта на корректность.

Проверки могут быть на удовлетворённость данных какому-либо условию.
Например, что дата не может быть в прошлом.
Они задаются элементом `<condition>`:

```xml
<validations>
  <condition id="dateInPast"
             on="birthday"
             message="Дата рождения не может быть в будущем">
    birthday <= today()
  </condition>
</validations>
```

<Sandbox height={400} projectId="data_object_validation_condition" />

Условия пишутся на языке JavaScript.

Так же проверки могут быть выполнены в базе данных или сервисах.
Например, что наименование должно быть уникальным.
Такие проверки задаются в элементе `<constraint>`:

```xml
<validations>
  <constraint id="uniqueName"
              message="Имя {name} уже существует"
              result="cnt == 0">
    <invocation>
      ... <!-- Провайдер данных -->
    </invocation>
    <in>
      <!--Входные данные-->
      <field id="id"/>
      <field id="name"/>
    </in>
    <out>
      <!--Выходные данные-->
      <field id="cnt"/>
    </out>
  </constraint>
</validations>
```

<Sandbox height={300} projectId="data_object_validation_constraint" />

Вызов проверки происходит аналогично вызову операции объекта,
т.е. определяет входные данные для [провайдера](#Data_providers)
и обрабатывает результат выполнения.

### Выборка {#Query}

Выборка — это срез данных объекта.
Выборки позволяют порционно получать данные объекта, фильтровать, сортировать и группировать их.

Выборки создаются с помощью файлов `[id].query.xml`.

```xml title="Структура выборки"
<?xml version='1.0' encoding='UTF-8'?>
<query xmlns="http://n2oapp.net/framework/config/schema/query-4.0"
  name="Моя выборка"
  object-id="myObject">
  <list>...</list> <!--Постраничное получение записей-->
  <count>...</count> <!--Получение общего количества записей-->
  <unique>...</unique> <!--Получение уникальной записи-->
  <fields>
    <!-- Поля выборки -->
    <field id="firstName"> ... </field>
    <field id="lastName"> ... </field>
  </fields>
</query>
```

За получение списка записей отвечает элемент `<list>`.
За получение общего количества записей — элемент `<count>`.

<Sandbox height={500} projectId="data_query_list" />

А за получение одной уникальной записи — `<unique>`.

<Sandbox height={300} projectId="data_query_unique" />

Элементов `<list>`, `<count>`, `<unique>` может быть несколько с разными наборами фильтров (атрибут `filters`).

```xml title="Структура выборки"
<list filters="firstName, lastName">
  ...
</list>
```

[Подробнее о выборках](../xml/query)

#### Поля выборки {#Query_fields}

Поле выборки — это информация о способе получения, фильтрации или сортировки данных одного поля объекта.

За каждый способ отвечает соответствующий элемент.
Например, за получение результатов отвечает `<select>`.
Если элемент не объявлен, то соответствующий способ взаимодействия с полем невозможен.
Например, если не объявлен элемент `<sorting>`, то сортировка по полю невозможна.

```xml title="Поле выборки"
<field id="name">
  <select>...</select><!--Способ получения данных-->
  <filters>...</filters><!--Способ фильтрации данных-->
  <sorting>...</sorting><!--Способ сортировки данных-->
</field>
```

#### Получение результатов выборки {#Query_select}

Для того, чтобы получить значения полей выборки, в некоторых случаях эти поля нужно передать на вход [провайдеру данных](#Data_providers).
Это можно сделать с помощью элемента `<select>`.

```xml title="Задание выражения для получения значения поля выборки sql запроса"
<field id="firstName">
  <select>t.name as firstName</select>
</field>
```

Чтобы получить значение этого поля, алиас столбца и идентификатор поля выборки должны совпадать.
Если они не совпадают можно использовать [маппинг](#Data_mapping_in_providers).

В теле `<select>` записывается выражение, которое можно вставить в sql или rest запрос с помощью переменной `select`.

```xml title="Задание шаблона select команды sql запроса"
<list>
    <sql>SELECT :select FROM mytalbe</sql>
<list>
```

#### Фильтры выборки {#Query_filters}

Фильтров у одного поля выборки может быть много.
Различаются они по типу фильтрации.

Существует несколько типов фильтраций.
Каждый из них задаётся соответствующим элементом:

__*Типы фильтраций*__

|Тип      |Описание                     |Тип данных    |
|---------|-----------------------------|--------------|
|eq       |Эквивалентность              |Любой         |
|like     |Строка содержит подстроку    |Строковые     |
|likeStart|Строка начинается с подстроки|Строковые     |
|in       |Входит в список              |Простые типы  |
|isNull   |Является null                |Любой         |
|contains |Входит в множество           |Списковые типы|
|overlaps |Пересекается с множеством    |Списковые типы|
|more     |Строго больше                |Числа и даты  |
|less     |Строго меньше                |Числа и даты  |

Почти на каждый из перечисленных типов есть тип с отрицанием, например, `notEq`.

```xml title="Задание фильтров в выборке"
<filters>
  <!-- Фильтр по "eq" -->
  <eq filter-id="gender.id">...</eq>
  <!-- Фильтр по "in" -->
  <in filter-id="genders*.id">...</in>
</filters>
```

<Sandbox height={700} projectId="data_query_list_filters" />

Атрибут `filter-id` задаёт уникальный идентификатор фильтра,
по которому можно определить поле выборки и тип фильтрации.

В теле фильтра записывается выражение,
которое можно вставить в sql или rest запрос с помощью переменной `filters`.

```xml title="Задание выражения фильтрации для sql запроса"
<filters>
  <eq>t.id = :id</eq>
</filters>
```

```xml title="Задание шаблона where команды sql запроса"
<list>
  <sql>SELECT t.name FROM mytable t WHERE :filters</sql>
</list>
```

##### Сортировка поля выборки {#Query_sortings}

Чтобы отсортировать поле выборки по возрастанию или по убыванию,
необходимо отправить эту информацию на вход в [провайдер данных](#Data_providers).

Выражение для отправки можно сформировать в теле элемента `<sorting>`, которое можно вставить в sql или rest запрос с помощью переменной `sortings`.

```xml title="Задание выражения сортировки для sql запроса"
<field id="name">
  <sorting>name :direction</sorting>
</field>
```
Переменная `direction` содержит в себе направление сортировки: `ASC` или `DESC`.
Название переменной можно сменить с помощью [маппинга](#Data_mapping_in_providers).

```xml title="Задание шаблона order by команды sql запроса"
<list>
  <sql>SELECT t.name FROM mytable t ORDER BY :sortings</sql>
</list>
```

### Тестовый провайдер {#Test}

Тестовый провайдер данных предназначен для целей обучения и прототипирования.
Он позволяет получать и сохранять данные используя json файлы "заглушки".
Тестовый провайдер задается элементом `<test>`.

Атрибут `file` указывает на расположение json файла в ресурсах проекта относительно папки `/src/resources`.
Содержимое json файла должно начинаться с массива.

```json title="/src/resources/test.json"
[
  { "id": 1, "name": "Foo" },
  { "id": 2, "name": "Bar" },
  ...
]
```

#### Получение данных

Для получения всех данных необходимо указать операцию `findAll`.

```xml title="Получение всех записей test провайдера"
<query>
  <list>
    <test file="test.json" operation="findAll"/>
  </list>
  ...
</query>
```
:::note
Атрибут `result-mapping` в элементе `<list>` указывать не нужно, потому что в случае с тестовым провайдером путь к списку всегда в корне json файла.
:::

Для получения одной записи необходимо указать операцию `findOne`.
```xml title="Получение одной записи test провайдера"
<query>
  <unique>
    <test file="test.json" operation="findOne"/>
  </unique>
  ...
</query>
```

Операция `findOne` отбирает первую запись из отфильтрованного списка.
```json
{ "id": 1, "name": "Foo" }
```

:::note
В случае, если данные для полей выборки находятся не в корне json объекта, например, вложены в объект "data"
```json
{
  "data": {
    "id": 1,
    "name": "test1"
  }
}
```
можно задать атрибут `result-mapping`, чтобы маппинг полей был более простым.
```xml
  <unique result-mapping="['data']">
    <test file="test.json" operation="findOne"/>
  </unique>
```
:::

#### Пагинация данных

Пагинация данных тестового провайдера выполняется автоматически.
Однако необходимо добавить получение общего количества записей.
Это можно сделать с помощью операции `count`.
```xml title="Получение количества записей в тестовом провайдере"
<count>
  <test file="test.json" operation="count"/>
</count>
```

#### Маппинг полей

Для маппинга полей выборки достаточно указать название свойства в json объекте, который будет получен после обработки `result-mapping`.
Например, для объекта
```json
{ "id": 1, "name": "Foo" }
```
маппинг полей будет таким
```xml {5,8} title="Маппинг полей тестового провайдера"
<query>
  ...
  <fields>
    <field id="id">
      <select mapping="['id']"/>  <!-- 1 -->
    </field>
    <field id="name">
      <select mapping="['name']"/> <!-- Foo -->
    </field>
  </fields>
</query>
```

:::note
Если идентификатор поля совпадает со свойством в json объекте, то маппинг можно не задавать
```xml
<query>
  ...
  <fields>
    <field id="id">
      <select/>  <!-- 1 -->
    </field>
    <field id="name">
      <select/> <!-- Foo -->
    </field>
  </fields>
</query>
```
:::

#### Фильтрация данных

Для задания фильтров тестового провайдера достаточно указать тип фильтра и `filter-id`.
Фильтрация json файла произойдет автоматически.

```xml {7,13} title="Фильтрация данных тестового провайдера"
<query>
  ...
  <fields>
    <field id="id">
      <select/>
      <filters>
        <eq filter-id="idEq"/>
      </filters>
    </field>
    <field id="name">
      <select/>
      <filters>
        <like filter-id="nameLike"/>
      </filters>
    </field>
  </fields>
</query>
```

#### Сортировка данных

Для сортировки списка тестового провайдера достаточно указать элемент `<sorting>` в поле поддерживающее сортировку.
Сортировка произойдет автоматически.

```xml {6,10} title="Сортировка данных тестового провайдера"
<query>
  ...
  <fields>
    <field id="id">
      <select/>
      <sorting/>
    </field>
    <field id="name">
      <select/>
      <sorting/>
    </field>
  </fields>
</query>
```

#### Операции над данными

Для добавления данных в json файл необходимо указать тип операции `create`.
```xml {4-6} title="Операции над данными тестового провайдера"
<operation id="create">
  <invocation>
    <test file="test.json"
          operation="create"
          primary-key-type="integer"
          primary-key="id"/>
  </invocation>
  <in>
    <field id="name" mapping="['name']"/>
  </in>
  <out>
    <field id="id" mapping="['id']"/>
  </out>
</operation>
```
Если `primary-key-type` равен `integer` для поля `id` будет сгенерировано число, следующее за максимальным из существующих в json файле.
Если `primary-key-type` равен `string`для поля `id` будет сгенерирована строка в формате UUID. По умолчанию `integer`.

Название первичного ключа можно изменить через атрибут `primary-key`. По умолчанию `id`.

__*Операции тестового провайдера*__

|Операция    |Описание                                           |
|------------|---------------------------------------------------|
|create      |Создание записи                                    |
|update      |Изменение записи                                   |
|delete      |Удаление записи                                    |
|updateMany  |Изменение нескольких записей                       |
|updateField |Изменение одного поля                              |
|deleteMany  |Удаление нескольких записей                        |
|echo        |Возврат входных данных                             |
|findAll     |Поиск всех записей                                 |
|findOne     |Поиск одной записи                                 |
|count       |Подсчет общего количества записей                  |

#### Обработка исключений

У тестового провайдера нет специфических исключений.
Любые ошибки тестового провайдера выбрасываются как внутренняя ошибка приложения.

### SQL {#SQL}

SQL провайдер позволяет выполнять SQL запросы к базе данных.
Запросы задаются в элементе `<sql>`
```xml
<sql>SELECT * FROM mytable</sql>
```
или в файле указанном в атрибуте `file` относительно ресурсов проекта
```xml
<sql file="/sql/mytable.sql"/>
```
```sql title="/src/resources/sql/mytable.sql"
SELECT * FROM mytable
```

#### Настройки соединения

Для соединения с БД необходимо добавить настройки приложения в файл `application.properties`
```properties title="Настройки соединения с БД"
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=postgres
spring.datasource.password=postgres
```

#### Получение данных
Для получения списка записей достаточно написать SELECT запрос.
```xml
<list>
  <sql>SELECT * FROM mytable t</sql>
</list>
```
Для получения одной записи по идентификатору, можно добавить WHERE блок с плейсхолдером.
Плейсхолдеры задаются через ведущее двоеточие `:something`.
```xml
<unique filters="idEq">
  <sql>SELECT * FROM mytable t WHERE t.id = :idEq</sql>
</unique>
```

Можно добавить специальный плейсхолдер `:select`, чтобы шаблонизировать запрос.
```xml
<sql>SELECT :select FROM mytable t</sql>
```
Плейсхолдер `:select` будет заменен на значения из элементов `<select>..</select>` в полях выборки.
Разделителем между разными элементами select будет запятая `, `. Например, для полей
```xml
<field id="id">
  <select>t.id as id</select>
</field>
<field id="name">
  <select>t.name as name</select>
</field>
```
итоговый запрос будет
```sql
SELECT t.id as id, t.name as name FROM mytable t
```

#### Пагинация данных

Для пагинации записей SQL запроса следует использовать плейсхолдеры `:limit` и `:offset`.
```xml title="Пагинация записей SQL запроса"
<list>
  <sql>SELECT * FROM mytable LIMIT :limit OFFSET :offset</sql>
</list>
```

Чтобы получить общее количество записей можно использовать другой запрос к БД с функцией агрегации.
```xml title="Получение количества записей SQL запроса"
<count count-mapping="[0]['cnt']">
  <sql>SELECT count(*) as cnt FROM mytable</sql>
</count>
```
В атрибуте `count-mapping` указывается выражение для получения числа записей.

#### Маппинг полей
В результате выполнения SQL запроса вернется объект `Map<String, Object>`,
где `String` алиас столбца запроса, а `Object` его значение.
Если алиас столбца не совпадает с идентификатором поля выборки, необходимо сделать маппинг.
```xml title="Маппинг полей SQL запроса"
<field id="firstName">
  <select mapping="['first_name']">t.name as first_name</select>
</field>
```

#### Фильтрация данных

Для задания фильтров SQL запроса нужно указать тип фильтра и идентификатор фильтра `filter-id`.
```xml title="Фильтрация SQL запроса"
<field id="id">
  <filters>
    <eq filter-id="idEq"/> <!-- Плейсхолдер :idEq -->
  </filters>
</field>
```
В этом случае будет доступен `PreparedStatement` плейсхолдер `:idEq` равный значению `filter-id`.
Если плейсхолдер нужно переименовать, можно использовать маппинг.
```xml title="Маппинг плейсхолдера фильтрации SQL запроса"
<field id="gender.id">
  <filters>
    <eq filter-id="gender.id" mapping="['gender_id']"/> <!-- Плейсхолдер :gender_id -->
  </filters>
</field>
```

Можно добавить специальный плейсхолдер `:filters`, чтобы шаблонизировать фильтрацию выборки.
```xml
<list filters-separator=" and ">
  <sql>SELECT * FROM mytable t WHERE :filters</sql>
</list>
```
Разделителем между разными фильтрами обычно должен быть ` and `, поэтому необходимо задать его атрибутом `filters-separator`.

Плейсхолдер `:filters` будет заменен на значения из элементов `<тип_фильтра>..</тип_фильтра>` в фильтрах выборки,
если значение фильтра не будет `null`.
```xml
<field id="name">
  <filters>
    <like filter-id="nameLike">t.name like '%'||:nameLike</like>
  </filters>
</field>
```
при наличии значения в `nameLike` итоговый запрос будет
```sql
SELECT * FROM mytable t WHERE t.name like '%'||:nameLike
```

:::note
Если ни одно значение фильтра не задано, плейсхолдер `:filters` будет заменен на `1=1`.
:::

#### Сортировка данных

Сортировка записей в SQL задается через блок `ORDER BY`
```xml
<sql>SELECT * FROM mytable ORDER BY name :nameDir</sql>
```
В поле, поддерживающее сортировку, необходимо добавить элемент`<sorting>`
и указать маппинг плейсхолдера для задания направления сортировки.

```xml {6,10} title="Сортировка данных SQL запроса"
<field id="name">
  <sorting mapping="['nameDir']"/>
  <!-- Если будет сортировка по полю name
       в плейсхолдер :nameDir попадет значение asc или desc -->
</field>
```

Можно добавить специальный плейсхолдер `:sorting`, чтобы шаблонизировать выражение сортировки.
```xml
<sql>SELECT * FROM mytable ORDER BY :sorting</sql>
```
Плейсхолдер `:sorting` будет заменен на значения из элементов `<sorting>..</sorting>` в полях выборки,
если по этому полю будет задана сортировка.
```xml
<field id="name">
  <sorting mapping="['nameDir']">name :nameDir</sorting>
</field>
```
при наличии сортировки `asc` по полю `name` итоговый запрос будет
```sql
SELECT * FROM mytable ORDER BY name asc
```
для сортировки по `desc` аналогично.

:::note
Если ни одно направление сортировки не задано, плейсхолдер `:sorting` будет заменен на `1`.
:::


#### Операции над данными

Для выполнения операций над данными нужно записать соответствующий SQL запрос.
```xml title="Выполнение операции SQL провайдером"
<operation id="create">
  <invocation>
    <sql>INSERT INTO mytable (first_name, last_name) VALUES (:first_name, :last_name)</sql>
  </invocation>
  <in>
    <field id="firstName" mapping="['first_name']"/>
    <field id="lastName" mapping="['last_name']"/>
  </in>
  <out>
    <field id="id" mapping="[0]"/>
  </out>
</operation>
```
Результатом `INSERT` запроса будет массив значений, добавленных в таблицу.
Чтобы получить первичный ключ, необходимо в `<out>` поле задать маппинг на первое добавленное значение.

#### Обработка исключений
При возникновении ошибок во время выполнения SQL запроса выбрасывается исключение `N2oQueryExecutionException`.
Из него можно получить исходный запрос `query` и сообщение от БД `message`.

```xml title="Получение данных об ошибке SQL"
<operation id="create" fail-message="Не удалось создать запись по причине {error}">
  ...
  <out-fail>
    <field id="sql" mapping="query"/> <!-- Исходный запрос -->
    <field id="error" mapping="message"/> <!-- Сообщение об ошибке -->
  </out-fail>
</operation>
```

### REST {#Rest}

REST провайдер выполняет http запросы к REST сервисам.
В теле запроса и ответа используется формат Json.

Запросы задаются в элементе `<rest>`
```xml
<rest>http://localhost:8081/api/myservice</rest>
```

#### Настройки соединения

Начальный адрес, например, `http://localhost:8081/api`, можно опускать в элементах `<rest>`, если он одинаковый для всех сервисов.
Для этого нужно задать настройку `n2o.engine.rest.url`
```shell title="application.properties"
n2o.engine.rest.url=http://localhost:8081/api
```
в результате REST запрос сократится до простого указания конечной точки
```xml
<rest>/myservice</rest>
```


Если для соединения используется прокси сервер, можно задать его настройки в атрибутах элемента `<rest>`
```xml
<rest proxy-host="192.168.1.0"
      proxy-port="3333">...</rest>
```

Для прочих настроек http запросов к REST сервисам, например, настроек аутентификации,
необходимо определить бин `RestTemplate`, с помощью которого REST провайдер выполняет запросы.
```js title="MyAppConfiguration.java"
@Bean
RestTemplate restTemplate() {
  RestTemplate restTemplate = new RestTemplate();
  ... //настройки restTemplate
  return restTemplate;
}
```

#### Получение данных
Для получения списка записей обычно нужно выполнить `GET` запрос к сервису получения данных.
```xml title="Получение списка записей REST запроса"
<list result-mapping="['content']">
  <rest>/mystore/goods</rest>
</list>
```
В атрибуте `result-mapping` нужно указать путь к списку объектов в ответе сервиса
```json title="GET /mystore/goods"
{
  "content": [
    { "id": 1, "name": "Товар 1", ... },
    { "id": 1, "name": "Товар 2", ... },
     ...
  ]
}
```

Для получения одной записи по идентификатору в REST сервисах обычно используется параметр пути.
Параметр пути можно задать через плейсхолдер.
Плейсхолдеры задаются в фигурных скобках `{something}`.
```xml title="Получение одной записи REST запроса"
<unique filters="idEq">
  <rest>/mystore/goods/{idEq}</rest>
</unique>
```

#### Пагинация данных

Для пагинации записей REST запроса следует использовать плейсхолдеры `{limit}` и `{offset}`.
```xml title="Пагинация записей REST запроса через offset"
<list>
  <rest>/mystore/goods?limit={limit}&amp;offset={offset}</rest>
</list>
```
В качестве альтернативы `{offset}` можно использовать плейсхолдер `{page}`.
```xml title="Пагинация записей REST запроса через page"
<list>
  <rest>/mystore/goods?size={limit}&amp;page={page}</rest>
</list>
```

:::note
Номер страницы `{page}` по умолчанию начинается с нуля `0`, но можно начать нумерацию страниц с `1` задав это в настройке
```shell title="application.properties"
#Паджинация начинается с нуля?
n2o.engine.pageStartsWith0=false
```
:::

Чтобы получить общее количество записей можно использовать атрибут `count-mapping`,
если REST сервис возвращает общее количество записей вместе со списком записей одной страницы.
```xml title="Получение количества записей REST запроса"
<list result-mapping="['content']" count-mapping="['totalElements']">
  <rest>/mystore/goods?size={limit}&amp;page={page}</rest>
</list>
```
В атрибуте `count-mapping` указывается путь к свойству, содержащему общее количество записей списка.
```json title="GET /mystore/goods?size=10&page=0"
{
  "content": [
    { "id": 1, "name": "Товар 1", ... },
    { "id": 2, "name": "Товар 2", ... },
     ...
    { "id": 10, "name": "Товар 10", ... }
  ],
  "totalElements": 100
}
```

#### Маппинг полей
В результате выполнения REST запроса вернется объект `DataSet`.
К DataSet можно обращаться как к `Map<String, Object>`, используя квадратные скобки `['field']`.
Для получения вложенных свойств используется символ "точка" `['field1.field2']`.

Если свойство json не совпадает с идентификатором поля выборки, необходимо сделать маппинг.
```xml title="Маппинг полей REST запроса"
<field id="firstName">
  <select mapping="['first_name']"/>
</field>
```

#### Фильтрация данных

Для задания фильтров REST запроса нужно указать тип фильтра и идентификатор фильтра `filter-id`.
```xml title="Фильтрация REST запроса"
<field id="id">
  <filters>
    <eq filter-id="idEq"/> <!-- Плейсхолдер {idEq} -->
  </filters>
</field>
```
В этом случае будет доступен плейсхолдер `{idEq}` равный значению `filter-id`.

Если плейсхолдер нужно переименовать, можно использовать маппинг.
```xml title="Маппинг плейсхолдера фильтрации REST запроса"
<field id="gender.id">
  <filters>
    <eq filter-id="gender.id" mapping="['gender_id']"/> <!-- Плейсхолдер {gender_id} -->
  </filters>
</field>
```

Можно добавить специальный плейсхолдер `{filters}` в REST запрос, чтобы шаблонизировать фильтрацию выборки.
```xml
<list filters-separator="&amp;">
  <rest>/mystore/goods?{filters}</rest>
</list>
```
Разделителем между разными фильтрами в параметрах запроса будет `&`, поэтому необходимо задать его атрибутом `filters-separator`.

Плейсхолдер `{filters}` будет заменен на значения из элементов `<тип_фильтра>..</тип_фильтра>` в фильтрах выборки,
если значение фильтра не будет `null`.
```xml
<field id="name">
  <filters>
    <like filter-id="nameLike">name={nameLike}</like>
  </filters>
</field>
```
при наличии значения "Ноутбук" в `nameLike` итоговый запрос будет
```shell
/mystore/goods?name=Ноутбук
```

:::note
Обычно в REST сервисе заранее прошито как то или иное поле фильтруется на сервере.
В таком случае использование разных видов фильтров (`<eq>`, `<like>`, `<in>` и др.) не оказывает влияение на запрос и является чисто семантическим.
:::

:::note
Если ни одно значение фильтра не задано, плейсхолдер `{filters}` будет заменен на пустую строку.
:::

#### Сортировка данных

Сортировка записей в REST сервисах обычно задается в параметрах запроса.
```xml
<rest>/mystore/goods?sort=name,{nameDir}</rest>
```
В поле, поддерживающее сортировку, необходимо добавить элемент`<sorting>`
и указать маппинг плейсхолдера для задания направления сортировки.

```xml title="Сортировка данных REST запроса"
<field id="name">
  <sorting mapping="['nameDir']"/>
  <!-- Если будет сортировка по полю name
       в плейсхолдер {nameDir} попадет значение asc или desc -->
</field>
```

Можно добавить специальный плейсхолдер `{sorting}`, чтобы шаблонизировать выражение сортировки.
```xml
<rest>/mystore/goods?{sorting}</rest>
```
Плейсхолдер `{sorting}` будет заменен на значения из элементов `<sorting>..</sorting>` в полях выборки,
если по этому полю будет задана сортировка.
```xml
<field id="name">
  <sorting mapping="['nameDir']">sort=name,{nameDir}</sorting>
</field>
```
при наличии сортировки `asc` по полю `name` итоговый запрос будет
```shell
GET /mystore/goods?sort=name,asc
```
для сортировки по `desc` аналогично.

:::note
Если ни одно направление сортировки не задано, плейсхолдер `{sorting}` будет заменен на пустую строку.
:::


#### Операции над данными

Для выполнения операций над данными нужно записать соответствующий REST запрос и http метод.
```xml title="Выполнение операции REST"
<operation id="create">
  <invocation>
    <rest method="POST">/mystore/goods</rest>
  </invocation>
  <in>
    <field id="name" mapping="['name']"/>
    <field id="price" mapping="['price']"/>
  </in>
  <out>
    <field id="id" mapping="['id']"/>
  </out>
</operation>
```
Входные параметры запроса будут собраны в `DataSet` объект, который будет сереализован в json и передан в теле запроса, если http метод `POST` или `PUT`.
В остальных случаях, входные параметры можно использовать в виде плейсхолдеров в самом запросе.

Выходные параметры можно использовать для обработки результата REST запроса.

#### Обработка исключений
При возникновении ошибок во время выполнения REST запроса выбрасывается исключение `N2oQueryExecutionException`.
Из него можно получить исходный запрос `query` и сообщение от REST сервиса `message`.

```xml title="Получение данных об ошибке REST"
<operation id="create" fail-message="Не удалось создать запись по причине {error}">
  ...
  <out-fail>
    <field id="sql" mapping="query"/> <!-- Исходный запрос -->
    <field id="error" mapping="message"/> <!-- Сообщение об ошибке -->
  </out-fail>
</operation>
```
#### Пример

<Sandbox height={400} projectId="data_providers_rest" />


### GraphQL {#GraphQL}

GraphQl провайдер позволяет выполнять GraphQl запросы к backend сервисам.

```xml title="Получение списка записей GraphQl провайдером"
<query>
  <list>
    <graphql>
        query persons(filters: { $$filters }, page: $$page, size: $$limit, sort: { $$sorting }) {
           id
           name
           age
        }
    <graphql/>
  </list>

  <fields>
    <field id="id">
      <select/>
    </field>

    <field id="name">
      <select/>
      <filters>
        <eq filter-id="name">{ name: {eq: $$name} }</eq>
      </filters>
      <sorting mapping="['nameDir']">{ name: $$nameDir }</sorting>
    </field>

    <field id="age">
      <select/>
    </field>
  </fields>
</query>
```

```xml title="Выполнение операции GraphQl провайдером"
<operation id="create">
  <invocation>
    <graphql>
      mutation {
         createPerson(name: $$name, age: $$age) {
            id
            name
            age
         }
      }
    </graphql>
  </invocation>
  <in>
    <field id="name"/>
    <field id="age"/>
  </in>
</operation>
```

#### Настройки GraphQl провайдера

Для подключения к backend сервису используется атрибут `endpoint`.
Вместо задания `endpoint` в каждом определении провайдера можно воспользоваться глобальной настройкой `n2o.engine.graphql.endpoint`.

Для обеспечения безопасного доступа к backend сервису необходимо использовать атрибут `access-token` или
глобальную настройку `n2o.engine.graphql.access-token`.

#### Экранирование строковых плейсхолдеров

Если значением плейсхолдера `$$` является строка, то значение оборачивается в кавычки, согласно синтаксису GraphQl.
```
$$name -> "Ann"
```
Для экранирования кавычек можно вместо `$$` плейсхолдера воспользоваться `$$$` плейсхолдером.
```
$$$name -> \"Ann\"
```

#### Обработка ошибок GraphQl провайдера

Для кастомизированной обработки ошибок результатов GraphQl сервера требуется включить её в реализации интерфейсов `OperationExceptionHandler`
 и `QueryExceptionHandler`.

```java title="Кастомный обработчик ошибок операций GraphQl сервера"
package com.example;

public class GraphQlOperationExceptionHandler implements OperationExceptionHandler {
    @Override
    public N2oException handle(CompiledObject.Operation o, DataSet data, Exception e) {
        ...
        // Обработка ошибки GraphQl сервера
        if (e instanceof N2oGraphQlException) {
            // Получение ответа, который вернул GraphQl сервер
            DataSet result = ((N2oGraphQlException) e).getResponse();
            DataList errors = (DataList) result.get("errors");
            ...
            // формирование сообщений валидации по ошибкам
            List<ValidationMessage> validationMessages = new ArrayList<>();
            for (Object obj : errors) {
                DataSet error = (DataSet) obj;
                String message = error.getString("message");
                String fieldId = error.getString("field");
                ...
                validationMessages.add(new ValidationMessage(message, fieldId, validationId));
            }
            return new N2oUserException("Ошибка валидации", null, validationMessages);
        }
        ...
    }
}
```

<Sandbox height={700} projectId="data_providers_graphql" />

### Java {#Java}

С помощью java провайдеров можно вызвать метод java класса.

Экземпляр класса можно получить с помощью IoC контейнера EJB или Spring.
Либо можно вызвать статический метод класса.

```xml title="Получение списка записей Java провайдером"
<query>
  <list>
    <java
      class="com.example.MyService"
      method="getList">
      <arguments>
        <argument
          type="criteria"
          class="com.example.MyCriteria"/>
      </arguments>
      <spring/>
    </java>
  </list>
  <fields>
    <field id="name">
      <select/>
      <filters>
          <eq/>
      </filters>
      <sorting/>
    </field>
  </fields>
</query>
```

```xml title="Выполнение операции Java провайдером"
<operation id="create">
  <invocation>
    <java class="com.example.MyService"
          method="create">
      <arguments>
        <argument
          type="entity"
          class="com.example.MyEntity"/>
      </arguments>
      <spring/>
    </java>
  </invocation>
  <in>
    <field id="firstName" mapping="[0].firstName"/>
    <field id="lastName" mapping="[0].lastName"/>
  </in>
</operation>
```

### MongoDB {#MongoDB}

Mondo DB провайдер выполняет запросы к Mongo DB базе данных.

```xml title="Получение списка записей Mongo DB провайдером"
<query>
    <list>
        <mongodb collection-name="person" operation="find"/>
    </list>
    <count>
        <mongodb collection-name="person" operation="countDocuments"/>
    </count>
    <fields>
        <field id="id" domain="string">
            <select/>
            <filters>
                <eq filter-id="id"/>
            </filters>
            <sorting/>
        </field>
        <field id="name">
            <select>name</select>
        </field>
    </fields>
</query>
```

В теле фильтров необходимо использовать синтаксис построения запросов в mongodb.
В соответствии с официальной документацией https://docs.mongodb.com/manual/reference/operator/ .
Используя плейсхолдер `#`, можно вставлять данные запроса(например значение фильтра)

```xml title="Пример"
<query>
    <list>
        <mongodb collection-name="person" operation="find"/>
    </list>
    <fields>
        <field id="id" domain="string">
            <select mapping="['_id'].toString()">_id</select>
            <filters>
                <eq filter-id="id">{ _id: new ObjectId('#id') }</eq>
            </filters>
            <sorting/>
        </field>
        <field id="name" domain="string">
            <select>name</select>
            <filters>
                <like filter-id="nameLike" mapping="['nameLikeMap']">{ name: { $regex: '.*#nameLikeMap.*'}}</like>
                <likeStart filter-id="nameStart">{ name: {$regex: '#nameStart.*'}}</likeStart>
            </filters>
            <sorting mapping="['sortName']">name :sortName</sorting>
        </field>
        <field id="birthday" domain="localdate">
            <select/>
            <filters>
                <more filter-id="birthdayMore">{birthday: {$gte: new ISODate(#birthdayMore)}}</more>
                <less filter-id="birthdayLess">{birthday: {$lte: new ISODate(#birthdayLess)}}</less>
            </filters>
        </field>
    </fields>
</query>
```

#### Автоматическая генерация для mongodb провайдера

В mongo db идентификатор записи всегда называется `_id`  и имеет тип `ObjectId`,
в N2O идентификатор записи должен называться `id` и иметь тип `string` или `integer`,
поэтому:

- `<select/>` для поля `id` преобразуется в `<select mapping="['_id'].toString()">_id</select>`
- для всех остальных полей `<select/>` преобразуется в `<select>id поля</select>`
- фильтр `eq` для поля `id` `<eq filter-id="id"/>` преобразуется в `<eq filter-id="id">{ _id: new ObjectId('#id') }</eq>`
фильтры других типов для поля id необходимо прописывать полностью.
Автоматическая генерация сработает только для типа eq.
- для других полей автоматическая генерация тела фильтра работает для всех типов.
Но необходимо учитывать, что она простая (для полей с типом дата необходимо писать самостоятельно, с учетом написания фильтров в mongodb).
- для поля `id` сортировка `<sorting/>` преобразуется в `<sorting>_id :idDirection</sorting>`
- для всех других полей, например `name`, `<sorting/>` преобразуется в `<sorting>name :nameDirection</sorting>`


```xml title="Пример"
<!-- Поле id -->
<field id="id" domain="string">
    <select/>
    <filters>
        <eq filter-id="id"/>
    </filters>
    <sorting/>
</field>

<!-- трансформируется в -->
<field id="id" domain="string">
    <select mapping="['_id'].toString()">_id</select>
    <filters>
        <eq filter-id="id">{ _id: new ObjectId('#id') }</eq>
    </filters>
    <sorting>_id :idDirection</sorting>
</field>

<!-- Поле name -->
<field id="name" domain="string">
    <select/>
    <filters>
        <like filter-id="nameLike"/>
        <likeStart filter-id="nameStart"/>
    </filters>
    <sorting/>
</field>

<!-- трансформируется в -->
<field id="name" domain="string">
    <select>name</select>
    <filters>
        <like filter-id="nameLike">{ name: { $regex: '.*#nameLike.*'}}</like>
        <likeStart filter-id="nameStart">{ name: {$regex: '#nameStart.*'}}</likeStart>
    </filters>
    <sorting>name :nameDirection</sorting>
</field>

<!-- Для даты тело фильтров необходимо прописывать самостоятельно -->
<field id="birthday" domain="localdate">
    <select/>
    <filters>
        <more filter-id="birthdayMore">{birthday: {$gte: new ISODate(#birthdayMore)}}</more>
        <less filter-id="birthdayLess">{birthday: {$lte: new ISODate(#birthdayLess)}}</less>
    </filters>
</field>
```

```xml title="Выполнение операции Mongo DB провайдером"
<operation id="create">
  <invocation>
    <mongodb collection-name="person" operation="insertOne"/>
  </invocation>
  <in>
    <field id="firstName"/>
    <field id="lastName"/>
  </in>
</operation>
```

Доступны операции insertOne, updateOne, deleteOne, deleteMany, countDocuments.

<Sandbox height={300} projectId="data_providers_mongodb" />


### Типы данных {#Data_types}

Типы данных в N2O предназначены для правильной передачи значений от клиента
к провайдерам данных.

__*Типы данных*__

|Тип          |Описание                        |
|-------------|--------------------------------|
|string       |Строки                          |
|integer      |Целые числа                     |
|date         |Дата и время                    |
|localdate    |Локальная Дата                  |
|localdatetime|Локальная дата и время          |
|boolean      |Логический тип (true / false)   |
|object       |Объект с вложенными свойствами  |
|numeric      |Число с точкой без округлений   |
|long         |Большое целое число             |
|short        |Короткое целое число            |

Любой из перечисленных типов может образовывать списковый тип данных,
если добавить в конец квадратные скобки:

```
integer[]
```

Типы данных в XML элементах задаются ключевым словом `domain`.

```xml title="Тип integer в поле выборки"
<query>
  ...
  <fields>
    <field id="gender.id" domain="integer">
      ...
    </field>
  </fields>
</query>
```

```xml title="Тип integer в параметрах операции"
<operation>
  ...
  <in>
    <field id="gender.id" domain="integer"/>
  </in>
</operation>
```

### Биндинг полей {#Bindings}

Поле ввода, поле выборки и параметр операции связываются друг
с другом через идентификатор `id`:

```xml title="Поле виджета"
<input-text id="firstName"/>
```

```xml title="Поле выборки"
<field id="firstName"> ... </field>
```

```xml title="Параметр операции"
<field id="firstName"/>
```

Подобная связь называется биндингом.

<Sandbox height={200} projectId="data_binding_simple" />

#### Биндинг составных полей {#Binding_select}

Составные поля обычно используются в компонентах выбора одного значения из списка:

```xml
<select id="gender">
  ... <!-- Содержит id и name -->
</select>
```

В json представлении модель данных `gender` выглядит так:

```json
{
    "gender": {
      "id" : 1,
      "name" : "Мужской"
    }
}
```

Если мы хотим использовать только `id`, можно записать биндинг через "точку":

```xml
<field id="gender.id"/> <!-- 1 -->
```

<Sandbox height={200} projectId="data_binding_select" />

#### Биндинг интервальных полей {#Binding_interval}

Интервальные поля — это поля, в которых можно задать начало и окончание:

```xml
<date-interval id="period">
  ... <!-- Содержит begin и end -->
</date-interval>
```

В json представлении модель данных `period` выглядит так:

```json
{
    "period": {
      "begin" : "01.01.2018 00:00",
      "end" : "31.12.2018 00:00"
    }
}
```

При передаче в два параметра нужно использовать окончание `.begin` и `.end`:

```xml
<field id="period.begin"/> <!-- 01.01.2018 00:00 -->
<field id="period.end"/> <!-- 31.12.2018 00:00 -->
```

<Sandbox height={350} projectId="data_binding_interval" />

#### Биндинг полей множественного выбора {#Binding_multi}

Поля множественного выбора позволяют выбрать несколько значений из предложенных вариантов:

```xml
<select id="regions" type="multi">
  ...<!-- Содержит несколько регионов -->
</select>
```

Модель данных `regions` в json:

```json
{
    "regions": [
      {
        "id" : 1,
        "name" : "Адыгея"
      },
      {
        "id" : 16,
        "name" : "Татарстан"
      }
    ]
}
```

Чтобы в параметре операции собрать только идентификаторы `regions`
необходимо использовать "звёздочку":

```xml
<field id="regions*.id"/> <!-- [1,16] -->
```

### Маппинг данных в провайдерах {#Mapping}

Входные и выходные параметры провайдера могут несоответствовать полям ввода.
Для их приведения в соответствие используется атрибут `mapping`.
Выражение в `mapping` записывается на языке [SpEL](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions).

Провайдеры используют тип входных параметров: "ключ значение".

:::note

Java провайдеры в качестве альтернативы могут использовать тип входных параметров "массив значений".
Поэтому в маппинге java можно также обращаться по индексу аргумента, например, `[0]`, `[1].name`.

:::

#### Маппинг фильтров {#Mapping_filters}

##### Маппинг фильтров в sql, rest, graphql и mongodb

```xml title="Маппинг фильтров в sql провайдере"
<query>
  <list>
    <sql>SELECT t.first_name, t.gender_id FROM mytable t WHERE :filters</sql>
  </list>
  <fields>
    <field id="firstName">
      <filters>
        <!-- Маппинг определяет ключ "first_name" в который будет скопировано значение фильтра "firstName" -->
        <like mapping="['first_name']">
          t.first_name like '%'||:first_name||'%'
        </like>
      </filters>
    </field>
    <field id="gender.id">
      <filters>
        <!-- Маппинг определяет ключ "gender_id" в который будет скопирован id фильтра "gender" -->
        <eq mapping="['gender_id']">
          t.gender_id = :gender_id
        </eq>
        <!-- Маппинг определяет ключ "genders" в который будет скопированы список id из фильтра "genders" -->
        <in mapping="['genders']">
          t.gender_id in (:genders)
        </in>
      </filters>
    </field>
  </fields>
</query>
```

<Sandbox height={500} projectId="data_providers_sql_mapping" />

```xml title="Маппинг фильтров в rest провайдере"
<query>
  <list>
    <rest>/api/myentity/items?{filters}</rest>
  </list>
  <fields>
    <field id="firstName">
      <filters>
        <!-- Маппинг определяет ключ "first_name" в который будет скопировано значение фильтра "firstName" -->
        <like mapping="['first_name']">
          first_name_like={first_name}
        </like>
      </filters>
    </field>
    <field id="gender.id">
      <filters>
        <!-- Маппинг определяет ключ "gender_id" в который будет скопирован id фильтра "gender" -->
        <eq mapping="['gender_id']">
          gender_id={gender_id}
        </eq>
        <!-- Маппинг определяет ключ "genders" в который будет скопированы список id из фильтра "genders" -->
        <in mapping="['genders']">
          gender_id_in={genders}
        </in>
      </filters>
    </field>
  </fields>
</query>
```

<Sandbox height={500} projectId="data_providers_rest_mapping" />

```xml title="Маппинг фильтров в graphql провайдере"
<query>
  <list>
    <graphql filter-separator=", and:">
      query posts(filter: $$filters) {
        score
        completed
      }
    </graphql>
   </list>

  <fields>
    <field id="score">
      <select mapping="['score']"/>
      <!-- при указании тела в фильтре оно будет добавлено в $$filters плейсхолдер -->
      <filters>
        <eq filter-id="score">{ score: {gt: $$score} }</eq>
      </filters>
    </field>
    <field id="completed">
      <select mapping="['completed']"/>
      <filters>
        <eq filter-id="completed">{ completed: $$completed }</eq>
      </filters>
    </field>
       ...
  </fields>
</query>
```

```xml title="Маппинг сортировки в mongodb провайдере"
<query>
  <list>
    <mongodb collection-name="user" operation="find"/>
  </list>
  <fields>
      <field id="userAge" domain="integer">
          <select/>
          <!-- Маппинг определяет ключ "sortUserAge" в который будет скопировано значение фильтра поля "userAge" -->
          <sorting mapping="['sortUserAge']">age :sortUserAge</sorting>
      </field>
  </fields>
</query>
```

#### Маппинг входных параметров операции {#Mapping_in}

##### Маппинг входных параметров операции sql

```xml title="Маппинг входных параметров в sql провайдере"
<operation>
  <invocation>
    <sql>INSERT INTO mytable (first_name, gender_id) VALUES (:first_name, :gender_id)</sql>
  </invocation>
  <in>
    <field id="name" mapping="['first_name']"/>
    <field id="gender.id" mapping="['gender_id']"/>
  </in>
</operation>
```

```xml title="Маппинг входных параметров в graphql провайдере"
<operation>
  <invocation>
    <graphql>mutation { create(score: $$user_score, completed: $$is_completed) {id score completed}</graphql>
  </invocation>
  <in>
    <field id="score" mapping="['user_score']"/>
    <field id="completed" mapping="['is_completed']"/>
  </in>
</operation>
```

##### Маппинг входных параметров операции rest

```text title="Запрос rest"
POST /api/myentity
```

```json title="Тело запроса"
{
    "firstName" : "John",
    "genderId" : 1
}
```

```xml title="Маппинг входных параметров в rest провайдере"
<operation>
  <invocation>
    <rest method="post">/api/myentity</rest>
  </invocation>
  <in>
    <field id="name" mapping="['firstName']"/>
    <field id="gender.id" mapping="['genderId']"/>
  </in>
</operation>
```

##### Маппинг входных параметров операции java

Для вызова метода java класса необходимо передать аргументы вызова в виде массива `Object[]`.
В java провайдере можно задать класс каждого аргумента.
Существует 3 типа аргументов: примитивы, сущности, критерии.

__*Типы аргументов java провайдера*__

|Тип      |Описание                                                                                               |
|---------|-------------------------------------------------------------------------------------------------------|
|primitive|Примитивные java классы: String, Integer, Boolean и т.п. Для них не нужно задавать атрибут `class`.    |
|entity   |Класс сущности. Для них не нужно задавать атрибут `class`, если в объекте задан атрибут `entity-class`.|
|criteria |Класс, содержащий фильтры, сортировки и паджинацию.                                                    |

###### Маппинг примитивов

Предположим у нас есть метод java класса с примитивным типом аргументов:

```java title="Метод java класса с примитивным типом аргументов"
package com.example;

class Calculator {
  public static Long sum(Long a, Long b) {
    return a + b;
  }
}
```

Чтобы смапить значение поля ввода в примитивный аргумент java метода, достаточно указать имя аргумента:

```xml title="Маппинг примитивов в java провайдере"
<operation>
  <invocation>
    <java class="com.example.Calculator" method="sum">
      <arguments>
        <argument type="primitive" name="arg1"/>
        <argument type="primitive" name="arg2"/>
      </arguments>
    </java>
  </invocation>
  <in>
    <field id="a" mapping="['arg1']"/>
    <field id="b" mapping="['arg2']"/>
  </in>
</operation>
```

:::note

Аргументы должны быть указаны в том же порядке, что и соответствующие аргументы java метода

:::

###### Маппинг сущности

```java title="Метод java класса с аргументом - сущностью"
@Service
class MyService {
  public Long create(MyEntity entity)  { ... }
}
```

```java title="java"
class MyEntity {
  private String name;
  private String surname;
  //getters and setters
}
```

Тип `entity` может быть задан только один раз среди всех аргументов.

```xml title="Маппинг сущности в java провайдере"
<operation>
  <invocation>
    <java class="com.example.MyService" method="create">
      <arguments>
        <argument type="entity" class="com.example.MyEntity"/>
      </arguments>
      <spring/>
    </java>
  </invocation>
  <in>
    <field id="firstName" mapping="[0].name"/>
    <field id="lastName" mapping="[0].surname"/>
  </in>
</operation>
```

###### Маппинг критериев

Критерии предназначены для передачи параметров фильтрации, сортировки и паджинации в java провайдер.
Как правило, фильтры задаются через поля класса, т.к. они уникальны для каждого случая.
А сортировка и паджинация задаются через базовый класс наследник.
N2O поддерживает несколько базовых классов критериев:

|Тип                                     |Описание                                                                  |
|----------------------------------------|--------------------------------------------------------------------------|
|org.springframework.data.domain.Pageable|Интерфейс библиотеки `spring-data` для задания паджинации                 |
|org.springframework.data.domain.Sort    |Класс библиотеки `spring-data` для задания сортировок                     |
|org.springframework.data.domain.Example |Интерфейс библиотеки `spring-data` для задания критериев по полям сущности|
|net.n2oapp.criteria.Criteria            |Класс библиотеки `criteria-api` для задания сортировок и паджинации       |

```java title="Метод java класса с аргументом - критерием"
@Service
class MyService {
  public List<MyEntity> getList(MyCriteria criteria)  { ... }
}
```

```java
class MyCriteria extends Criteria {
  private Date birtdayBefore;
  private Date birtdayAfter;
  //getters and setters
}
```

Тип `criteria` может быть задан только один раз среди всех аргументов.
Маппинга сортировки и паджинации не предусмотрено, они передаются через базовый класс наследник.


```xml title="Задание фильтров в java провайдере"
<query>
  <list>
    <java
      class="com.example.MyService"
      method="getList">
      <arguments>
        <argument
          type="criteria"
          class="com.example.MyCriteria"/>
      </arguments>
      <spring/>
    </java>
  </list>
  <fields>
    <field id="birthday">
      <filters>
          <more filter-id="birthdays.begin" mapping="[0].birthdayAfter"/>
          <less filter-id="birthdays.end" mapping="[0].birthdayBefore"/>
      </filters>
      <sorting/>
    </field>
  </fields>
</query>
```

#### Маппинг результатов выборки {#Mapping_out}
Выборка возвращает список объектов при вызове через `<list>`, или один объект, при вызове через `<unique>`.
Задача маппинга — задать соответствие между свойством вернувшегося объекта и полем выборки.

##### Маппинг результатов выборки sql

```sql title="Sql запрос"
SELECT name as fname, surname as lname FROM mytable
```

```xml title="Маппинг результатов выборки sql провайдера"
<query>
  <list>
    <sql>SELECT name as fname, surname as lname FROM mytable</sql>
  </list>
  <count>
    <sql>SELECT count(*) FROM mytable</sql>
  </count>
  <fields>
    <field id="firstName">
      <select mapping="['fname']"/>
    </field>
    <field id="lastName">
      <select mapping="['lname']"/>
    </field>
  </fields>
</query>
```

##### Маппинг результатов выборки graphql

```json title="GraphQl запрос"
query persons() {name age}
```

```xml title="Маппинг результатов выборки sql провайдера"
<query>
  <list result-mapping="['data.persons']">
    <graphql>
      query persons() {
        name
        age
      }
    </graphql>
  </list>

  <fields>
    <field id="personName">
      <select mapping="['name']"/>
    </field>
    <field id="personAge">
      <select mapping="['age']"/>
    </field>
  </fields>
</query>
```

##### Маппинг результатов выборки rest

```text title="Запрос rest сервиса"
GET /api/myentity/items
```

```json title="Ответ rest сервиса"
{
  "data" : [
      {
        "name" : "John",
        "surname" : "Doe"
      },
      ...
  ],
  "cnt" : 123
}
```

```xml title="Маппинг результатов выборки из rest провайдера"
<query>
  <list>
    <rest
      result-mapping="data"
      count-mapping="cnt">/api/myentity/items</rest>
  </list>
  <fields>
    <field id="firstName">
      <select mapping="['name']"/>
    </field>
    <field id="lastName">
      <select mapping="['surname']"/>
    </field>
  </fields>
</query>
```

##### Маппинг результатов выборки java

```java title="Метод java класса, возвращающий Spring Data Page"
@Repository
interface MyRepository extends JpaRepository<MyEntity, Long> {
  Page<MyEntity> findAll();
}
```

```java
class MyEntity {
  private String name;
  private String surname;
  //getters and setters
}
```

```xml title="Маппинг результатов выборки в java провайдере"
<query>
  <list
    result-mapping="content"
    count-mapping="totalElements">
    <java
      class="com.example.MyRepository"
      method="findAll">
      <spring/>
    </java>
  </list>
  <fields>
    <field id="firstName">
      <select mapping="['name']"/>
    </field>
    <field id="lastName">
      <select mapping="['surname']"/>
    </field>
  </fields>
</query>
```

```xml title="Маппинг результатов выборки в mongodb провайдере"
<query>
  <list>
    <mongodb collection-name="user" operation="find"/>
  </list>
  <fields>
      <field id="userAge" domain="integer">
          <!-- маппинг определяет из какого поля результатов выборки из бд взять значение для userAge -->
          <select mapping="['age']">age</select>
      </field>
  </fields>
</query>
```

#### Маппинг результатов операции {#Mapping_result}

Чтобы вернуть данные от провайдера, после выполнения операции, используется элемент `<out>`:

##### Маппинг результатов sql

```xml title="Получение результата выполнения sql провайдера"
<operation>
  <invocation>
    <sql>INSERT INTO mytable (first_name, gender_id) VALUES (:first_name, :gender_id)</sql>
  </invocation>
  <out>
    <field id="id" mapping="[0]"/>
  </out>
</operation>
```

В примере результатом выполнения SQL запроса будет вставленная в таблицу запись.
Эту запись можно получить обратным маппингом, где 0 - номер колонки вставленной записи.

##### Маппинг результатов rest

```text title="Запрос rest"
POST /api/myentity
```

```json title="Ответ rest"
{
  "result" : 123
}
```

```xml title="Получение результата выполнения rest провайдера"
<operation>
  <invocation>
    <rest method="post">/api/myentity</rest>
  </invocation>
  <out>
    <field id="id" mapping="['result']"/>
  </out>
</operation>
```

##### Маппинг результатов mongodb

Операция insertOne возвращает всегда id, операции updateOne, deleteOne и deleteMany
не возвращают ничего, поэтому маппинг результатов имеет место только для insertOne.

```xml title="Пример"
<operation id="create">
    <invocation>
        <mongodb collection-name="user" operation="insertOne"/>
    </invocation>
    <in>
        <field id="name" mapping="['name']"/>
        <field id="age" mapping="['age']"/>
    </in>
    <out>
        <field id="id" mapping="#this"/>
    </out>
</operation>
```

#### Маппинг данных в Entity {#Mapping_entity}

При использовании java провайдеров объект и выборка чаще всего работают с одной и той же сущностью.
В N2O можно задать маппинг полей объекта на поля сущности в одном месте, и в дальнейшем не повторяться при выполнении операций, валидаций и выборок.

Для этого в объекте есть специальный атрибут `entity-class` и список полей `<fields>`:

```xml title="Определение entity класса в объекте"
<object
  entity-class="com.example.MyEntity">
  <fields>
    ...<!--Маппинг полей Entity-->
  </fields>
</object>
```

##### Маппинг простых полей сущности

Поля делятся на простые и составные.

Простые поля имеют примитивный тип данных (`Integer`, `String`, `Date` и т.п.)
Составные поля либо ссылаются на другие N2O объекты, либо имеют вложенные поля.


```java title="Класс сущности с простыми полями"
@Entity
class MyEntity {
  @Id
  @Column
  private Long id;
  @Column
  private Date birtDate;
  //getters and setters
}
```

```xml title="Маппинг простых полей"
<object entity-class="com.example.MyEntity">
  <fields>
    <!-- Простые поля -->
    <field id="id" domain="long" mapping="['id']"/>
    <field id="birthday" domain="date" mapping="['birthDate']"/>
  </fields>
</object>
```

Атрибут `id` задаёт поле виджета, атрибут `mapping` - поле сущности.

##### Маппинг полей @ManyToOne и @OneToOne

```java title="Класс сущности с @ManyToOne и @OneToOne"
@Entity
class MyEntity {
  @ManyToOne
  private Gender gender;
  @OneToOne
  private Address addr;
  //getters and setters
}
```

```xml title="Маппинг полей с @OneToOne"
<fields>
  <reference id="address"
    mapping="['addr']">
    <!-- Вложенные поля -->
    <field id="home" domain="string"/>
    <field id="work" domain="string"/>
  </reference>
</fields>
```

```xml title="Вариант с определением полей во внешнем файле"
<fields>
  <reference id="address"
    mapping="['addr']"
    object-id="address"/> <!-- Ссылка на объект address.object.xml -->
</fields>
```

```xml title="address.object.xml"
<!-- обратите внимание, что класс сущности может быть указан во внешнем файле -->
<object xmlns="http://n2oapp.net/framework/config/schema/object-4.0"
        entity-class="org.example.Address">
    <fields>
      <field id="home" domain="string"/>
      <field id="work" domain="string"/>
    </fields>
</object>
```

:::note

Описывать поля можно внутри составного поля (reference, list или set) или во внешнем файле.
Однако, если вы опишите поля в обоих местах, то более приоритетным будет вариант задания полей внутри составного поля.
Все поля будут взяты из него, а для полей присутствующих в обоих файлах (т.е. с совпадающим id)
будет произведено слияние в пользу текущего объекта.

:::

```xml title="Маппинг полей с @ManyToOne"
<fields>
  <reference id="sex"
    mapping="['gender']"
    required="true"
    object-id="gender"/>
</fields>
```

##### Маппинг полей @OneToMany и @ManyToMany

Поля объекта могут быть множественными.
Есть несколько типов множественности:

__*Типы множественности*__

|Тип |Описание       |
|----|---------------|
|list|Список значений|
|set |Набор значений |


```java title="Класс сущности с множественными полями"
@Entity
class MyEntity {
  @OneToMany
  private Set<Status> statuses;
  @ManyToMany
  private List<Address> addrs;
  //getters and setters
}
```

```xml title="Маппинг полей с @OneToMany и @ManyToMany"
<fields>
  <set id="statuses"
    mapping="['statuses']">
    <!--Вложенные поля-->
    <field id="id" domain="integer"/>
    <field id="name" domain="string"/>
  </set>
  <list id="addresses"
    mapping="['addrs']"
    object-id="address"/><!--Ссылка на объект-->
</fields>
```

##### Использование полей объекта

Если поле было задано в полях объекта, то при описании операций объекта не требуется определять
маппинг и прочие атрибуты, а также вложенную структуру. Достаточно задать только идентификаторы параметров.
В случае, если поле будет присутствовать в обоих местах, то будет произведено слияние с приоритетом в пользу поля в операции.

```java
@Service
class MyService {
  MyEntity create(MyEntity entity) { ... }
}
```

```xml title="Использование полей объекта в операции"
<object entity-class="com.example.Employee">
  <!-- Маппинг и структура полей сущности -->
  <fields>
    <field id="name" mapping="['name']" normalize="..."/>
    <reference id="org" mapping="['organization']" object-id="org"/>
    <list id="departments" entity-class="com.example.Department">
      <field id="id"/>
      <field id="name"/>
    </list>
  </fields>

  <operations>
    <operation>
      <invocation>
        <java method="create">
          <arguments>
            <argument type="entity"/>
          </arguments>
          <spring/>
        </java>
      </invocation>
      <in>
        <!-- Перечисление только нужных полей -->
        <!-- Не нужно задавать ни структуру, ни атрибуты -->
        <field id="name"/>
        <reference id="org"/>
        <list id="departments"/>
      </in>
      <out>
        <field id="id"/>
      </out>
    </operation>
  </operations>
</object>
```

[Пример](https://sandbox.n2oapp.net/new/data/object/nesting_object_fields_for_args_provider)
