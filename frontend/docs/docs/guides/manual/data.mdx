---
title: Провайдеры данных
description: ""
---
import { Sandbox } from '../../../src/components/Sandbox/Sandbox'

В N2O Framework визуальные компоненты связываются с данными через объекты и выборки.
Объекты и выборки делегируют свои вызовы провайдерам данных.

Провайдеры — это универсальный способ обращения к источнику или к сервису предоставляющему данные.
N2O поддерживает провайдеры SQL, REST, GraphQl, Spring Beans, EJB, MongoDB и другие.

![](./images/data-f1687.png)

### Объект {#Object}

Объект — это сущность предметной области.
Он объединяет в себе все операции над этой сущностью и её валидации.

Объекты создаются с помощью файлов `[id].object.xml`.

```xml
<?xml version='1.0' encoding='UTF-8'?>
<object xmlns="http://n2oapp.net/framework/config/schema/object-4.0"
  name="Мой объект">
  <fields>
    <!-- Поля объекта -->
    <field id="id"/>
    <field id="name"/>
    <field id="birthday"/>
    <list id="docs">...</list>
    ...
  </fields>
  <operations>
    <!-- Операции объекта -->
    <operation id="create">...</operation>
    <operation id="update">...</operation>
    <operation id="delete">...</operation>
    ...
  </operations>
  <validations>
    <!-- Валидации объекта -->
    <constraint id="uniqueName">...</constraint>
    <condition id="dateInPast">...</condition>
    ...
  </validations>
</object>
```

[Подробнее об объектах](../xml/object)

#### Операции объекта {#Object_operations}

Над объектом можно выполнять операции, например, создание или удаление.
Операция определяет входные, выходные данные для [провайдера](#Data_providers) и задаёт список валидаций.

```xml title="Операция объекта"
<operation id="create">
  <invocation>
    ... <!--Провайдер данных-->
  </invocation>
  <in>
      <!--Входные данные-->
      <field id="name"/>
      <field id="birthday"/>
  </in>
  <out>
      <!--Выходные данные-->
      <field id="id"/>
  </out>
  <fail-out>
      <!--Выходные данные в случае ошибки операции-->
      <field id="message" mapping="#this.getMessage()"/>
  </fail-out>
  <validations>...</validations><!--Валидации операций-->
</operation>
```

<Sandbox height={200} projectId="data_object_operations" />

#### Валидации объекта {#Object_validations}

Валидации — это проверки объекта на корректность.

Проверки могут быть на удовлетворённость данных какому-либо условию.
Например, что дата не может быть в прошлом.
Они задаются элементом `<condition>`:

```xml
<validations>
  <condition id="dateInPast"
             on="birthday"
             message="Дата рождения не может быть в будущем">
    birthday <= today()
  </condition>
</validations>
```

<Sandbox height={400} projectId="data_object_validation_condition" />

Условия пишутся на языке JavaScript.

Так же проверки могут быть выполнены в базе данных или сервисах.
Например, что наименование должно быть уникальным.
Такие проверки задаются в элементе `<constraint>`:

```xml
<validations>
  <constraint id="uniqueName"
              message="Имя {name} уже существует"
              result="cnt == 0">
    <invocation>
      ... <!-- Провайдер данных -->
    </invocation>
    <in>
      <!--Входные данные-->
      <field id="id"/>
      <field id="name"/>
    </in>
    <out>
      <!--Выходные данные-->
      <field id="cnt"/>
    </out>
  </constraint>
</validations>
```

<Sandbox height={300} projectId="data_object_validation_constraint" />

Вызов проверки происходит аналогично вызову операции объекта,
т.е. определяет входные данные для [провайдера](#Data_providers)
и обрабатывает результат выполнения.

### Выборка {#Query}

Выборка — это срез данных объекта.
Выборки позволяют порционно получать данные объекта, фильтровать, сортировать и группировать их.

Выборки создаются с помощью файлов `[id].query.xml`.

```xml title="Структура выборки"
<?xml version='1.0' encoding='UTF-8'?>
<query xmlns="http://n2oapp.net/framework/config/schema/query-4.0"
  name="Моя выборка"
  object-id="myObject">
  <list>...</list> <!--Постраничное получение записей-->
  <count>...</count> <!--Получение общего количества записей-->
  <unique>...</unique> <!--Получение уникальной записи-->
  <fields>
    <!-- Поля выборки -->
    <field id="firstName"> ... </field>
    <field id="lastName"> ... </field>
  </fields>
</query>
```

За получение списка записей отвечает элемент `<list>`.
За получение общего количества записей — элемент `<count>`.

<Sandbox height={500} projectId="data_query_list" />

А за получение одной уникальной записи — `<unique>`.

<Sandbox height={300} projectId="data_query_unique" />

Элементов `<list>`, `<count>`, `<unique>` может быть несколько с разными наборами фильтров (атрибут `filters`).

```xml title="Структура выборки"
<list filters="firstName, lastName">
  ...
</list>
```

[Подробнее о выборках](../xml/query)

#### Поля выборки {#Query_fields}

Поле выборки — это информация о способе получения или сортировки данных одного поля объекта.

Существует три типа полей выборки: простое `<field>`, составное `<reference>` и списковое `<list>`.
Составное и списковое поля предназначены для работы со сложными объектами и
могут содержать внутри себя все три типа полей выборки.

```xml title="Поля выборки"
<fields>
    <field id="name"/>
    <refernce id="organization">
        <field id="code/>
        <list id="employess">
            <field id="id"/>
            <field id="email"/>
            <reference id="address">...</reference>
        </list>
    </reference>
</fields>
```

#### Получение результатов выборки {#Query_select}

Для того чтобы получить значения полей выборки, в некоторых случаях эти поля нужно передать на вход [провайдеру данных](#Data_providers).
Это можно сделать с помощью атрибута `select-expression`.

```xml title="Задание выражения для получения значения поля выборки sql запроса"
<field id="firstName" select-expression="t.name as firstName"/>
```

Чтобы получить значение этого поля, алиас столбца и идентификатор поля выборки должны совпадать.
Если они не совпадают можно использовать [маппинг](#Data_mapping_in_providers).

В качестве значения `select-expression` записывается выражение, которое можно вставить в sql или rest запрос
с помощью переменной `select`.

```xml title="Задание шаблона select команды sql запроса"
<list>
    <sql>SELECT :select FROM mytalbe</sql>
<list>
```

`select-expression` сложных полей поддерживает иерархическую подстановку выражений вложенных полей. Для этого в теле выражения
нужно установить некоторую переменную с плейсхолдером, использующимся в [провайдере данных](#Data_providers),
а затем эту переменную указать в атрибуте `select-key`

```xml title="Иерархическая подстановка select-expression для сложных полей GraphQL провайдера данных"
<list id="showrooms" select-key="showroomsSelect" select-expression="showrooms { $$showroomsSelect }">
    <field id="id" select-expression="id"/>
    <field id="name" select-expression="name"/>
    <reference id="owner" select-expression="owner { $$ownerSelect }" select-key="ownerSelect">
        <field id="name" select-expression="name"/>
        <field id="inn" select-expression="inn"/>
    </reference>
</list>
```

После подстановки значений атрибутов `select-expression` внутренних полей вместо переменных showroomsSelect и ownerSelect
в запросе будет использована строка `...showrooms { id name owner { name inn } }...`. Для полей, значения которых не
должны приходить из провайдера, необходимо указать `select="false"`

```xml
<fields>
    <field id="id" select="false" default-value="{id}"/>
    <field id="name"/>
</fields>
```

##### Сортировка поля выборки {#Query_sortings}

Простые поля поддерживают сортировку. Чтобы отсортировать простое поле выборки по возрастанию или по убыванию,
необходимо отправить эту информацию на вход в [провайдер данных](#Data_providers).

В атрибуте `sorting-expression` указывается выражение для отправки,
которое можно вставить в sql или rest запрос с помощью переменной `sortings`.

```xml title="Задание выражения сортировки для sql запроса"
<field id="name" sorting-expression="name :direction"/>
```
Переменная `direction` содержит в себе направление сортировки: `ASC` или `DESC`.
Название переменной можно сменить с помощью атрибута `sorting-mapping`.

```xml title="Задание шаблона order by команды sql запроса"
<list>
  <sql>SELECT t.name FROM mytable t ORDER BY :sortings</sql>
</list>
```

#### Фильтры выборки {#Query_filters}

Фильтров у одного поля выборки может быть много.
Различаются они по типу фильтрации.

Существует несколько типов фильтраций.
Каждый из них задаётся соответствующим элементом:

__*Типы фильтраций*__

|Тип      |Описание                     |Тип данных    |
|---------|-----------------------------|--------------|
|eq       |Эквивалентность              |Любой         |
|like     |Строка содержит подстроку    |Строковые     |
|likeStart|Строка начинается с подстроки|Строковые     |
|in       |Входит в список              |Простые типы  |
|isNull   |Является null                |Любой         |
|contains |Входит в множество           |Списковые типы|
|overlaps |Пересекается с множеством    |Списковые типы|
|more     |Строго больше                |Числа и даты  |
|less     |Строго меньше                |Числа и даты  |

Почти на каждый из перечисленных типов есть тип с отрицанием, например, `notEq`.

```xml title="Задание фильтров в выборке"
<filters>
  <!-- Фильтр по "eq" -->
  <eq field-id="gender.id">...</eq>
  <!-- Фильтр по "in" -->
  <in field-id="genders*.id">...</in>
</filters>
```

<Sandbox height={700} projectId="data_query_list_filters" />

Для фильтра является обязательным атрибут `field-id`, в нем указывается идентификатор поля выборки,
по которому будет осуществлена фильтрация.
Для того чтобы сослаться на вложенное поле, необходимо использовать "точку"
в качестве разделителя идентификаторов родительского и дочернего полей.

```xml title="Задание выражения фильтрации для sql запроса"
<filters>
    <eq field-id="code">...</eq>
    <contains field-id="resources.id">...</contains>
</filters>

<fields>
    <field id="code"/>
    <list id="resources">
        <field id="id"/>
        <field id="name"/>
    </list>
</fields>
```

В теле фильтра записывается выражение,
которое можно вставить в sql или rest запрос с помощью переменной `filters`.

```xml title="Задание выражения фильтрации для sql запроса"
<filters>
  <eq field-id="id">t.id = :id</eq>
</filters>
```

```xml title="Задание шаблона where команды sql запроса"
<list>
  <sql>SELECT t.name FROM mytable t WHERE :filters</sql>
</list>
```

### Тестовый провайдер {#Test}

Тестовый провайдер данных предназначен для целей обучения и прототипирования.
Он позволяет получать и сохранять данные используя json файлы "заглушки".
Тестовый провайдер задается элементом `<test>`.

Атрибут `file` указывает на расположение json файла в ресурсах проекта относительно папки `/src/resources`.
Содержимое json файла должно начинаться с массива.

```json title="/src/resources/test.json"
[
  { "id": 1, "name": "Foo" },
  { "id": 2, "name": "Bar" },
  ...
]
```

#### Получение данных

Для получения всех данных необходимо указать операцию `findAll`.

```xml title="Получение всех записей test провайдера"
<query>
  <list>
    <test file="test.json" operation="findAll"/>
  </list>
  ...
</query>
```
:::note
Атрибут `result-mapping` в элементе `<list>` указывать не нужно, потому что в случае с тестовым провайдером путь к списку всегда в корне json файла.
:::

Для получения одной записи необходимо указать операцию `findOne`.
```xml title="Получение одной записи test провайдера"
<query>
  <unique>
    <test file="test.json" operation="findOne"/>
  </unique>
  ...
</query>
```

Операция `findOne` отбирает первую запись из отфильтрованного списка.
```json
{ "id": 1, "name": "Foo" }
```

:::note
В случае, если данные для полей выборки находятся не в корне json объекта, например, вложены в объект "data"
```json
{
  "data": {
    "id": 1,
    "name": "test1"
  }
}
```
можно задать атрибут `result-mapping`, чтобы маппинг полей был более простым.
```xml
  <unique result-mapping="['data']">
    <test file="test.json" operation="findOne"/>
  </unique>
```

:::

#### Маппинг полей

Для маппинга полей выборки достаточно указать название свойства в json объекте, который будет получен после обработки `result-mapping`
и `result-normalize`.
Например, для объекта
```json
{ "id": 1, "name": "Foo" }
```
маппинг полей будет таким
```xml {5,8} title="Маппинг полей тестового провайдера"
<query>
  ...
  <fields>
    <field id="id" mapping="['id']"/> <!-- 1 -->
    <field id="name" mapping="['name']"/> <!-- Foo -->
  </fields>
</query>
```

:::note
Если идентификатор поля `id` совпадает с свойством в json объекте, то маппинг можно не задавать
```xml
<query>
  ...
  <fields>
    <field id="id"/> <!-- 1 -->
    <field id="name"/> <!-- Foo -->
  </fields>
</query>
```
:::

#### Фильтрация данных

Для задания фильтров тестового провайдера достаточно указать тип фильтра и `field-id`.
Фильтрация json файла произойдет автоматически.

```xml {7,13} title="Фильтрация данных тестового провайдера"
<query>
  ...
  <filters>
    <eq field-id="id"/>
    <like field-id="name"/>
  </filters>

  <fields>
    <field id="id"/>
    <field id="name"/>
  </fields>
</query>
```

#### Сортировка данных

Для сортировки списка тестового провайдера достаточно указать `sorting="true"` в простом поле поддерживающем сортировку.
Сортировка произойдет автоматически.

```xml {6,10} title="Сортировка данных тестового провайдера"
<query>
  ...
  <fields>
    <field id="id" sorting="true"/>
    <field id="name" sorting="true"/>
  </fields>
</query>
```

#### Операции над данными

Для добавления данных в json файл необходимо указать тип операции `create`.
```xml {4-6} title="Операции над данными тестового провайдера"
<operation id="create">
  <invocation>
    <test file="test.json"
          operation="create"
          primary-key-type="integer"
          primary-key="id"/>
  </invocation>
  <in>
    <field id="name" mapping="['name']"/>
  </in>
  <out>
    <field id="id" mapping="['id']"/>
  </out>
</operation>
```
Если `primary-key-type` равен `integer` для поля `id` будет сгенерировано число, следующее за максимальным из существующих в json файле.
Если `primary-key-type` равен `string`для поля `id` будет сгенерирована строка в формате UUID. По умолчанию `integer`.

Название первичного ключа можно изменить через атрибут `primary-key`. По умолчанию `id`.

__*Операции тестового провайдера*__

|Операция    |Описание                                           |
|------------|---------------------------------------------------|
|create      |Создание записи                                    |
|update      |Изменение записи                                   |
|delete      |Удаление записи                                    |
|updateMany  |Изменение нескольких записей                       |
|updateField |Изменение одного поля                              |
|deleteMany  |Удаление нескольких записей                        |
|echo        |Возврат входных данных                             |
|findAll     |Поиск всех записей                                 |
|findOne     |Поиск одной записи                                 |
|count       |Подсчет общего количества записей                  |

#### Обработка исключений

У тестового провайдера нет специфических исключений.
Любые ошибки тестового провайдера выбрасываются как внутренняя ошибка приложения.

### SQL {#SQL}

SQL провайдер позволяет выполнять SQL запросы к базе данных, описанные прямо в XML файле.

```xml title="Получение списка записей SQL провайдером"
<query>
  <list>
    <sql>SELECT :select FROM mytable WHERE :filters ORDER BY :sortings</sql>
  </list>
  <count>
    <sql>SELECT count(*) FROM mytable WHERE :filters</sql>
  </count>

  <filters>
    <eq field-id="name">name = :name</eq>
  </filters

  <fields>
    <field id="name" select-expression="name" sorting-expression="name :direction"/>
  </fields>
</query>
```

```xml title="Выполнение операции SQL провайдером"
<operation id="create">
  <invocation>
    <sql>INSERT INTO mytable (first_name, last_name) VALUES (:firstName, :lastName)</sql>
  </invocation>
  <in>
    <field id="firstName"/>
    <field id="lastName"/>
  </in>
</operation>
```

#### Настройки SQL провайдера

Если приложение обращается только к одной базе данных,
то настройки подключения соответствуют настройкам `spring.datasource`.

Если необходимо подключиться к другой базе данных, то можно задать
класс jdbc драйвера настройкой `n2o.engine.jdbc.driver-class-name`.

<Sandbox height={400} projectId="data_providers_sql" />


### REST {#Rest}

REST провайдер выполняет http запросы к backend сервисам.

```xml title="Получение списка записей REST провайдером"
<query>
  <list>
    <rest>/api/myentity/items?{filters}&amp;{sortings}</rest>
  </list>
  <unique filters="id">
    <rest>/api/mytable/{id}</rest>
  </unique>

  <filters>
    <eq field-id="name">name={name}</eq>
  </filters>

  <fields>
    <field id="name" sorting-expression="sort=name:{direction}"/>
  </fields>
</query>
```

```xml title="Выполнение операции REST провайдером"
<operation id="create">
  <invocation>
    <rest method="post">/api/myentity</rest>
  </invocation>
  <in>
    <field id="firstName"/>
    <field id="lastName"/>
  </in>
</operation>
```

<Sandbox height={400} projectId="data_providers_rest" />


### GraphQL {#GraphQL}

GraphQl провайдер позволяет выполнять GraphQl запросы к backend сервисам.

```xml title="Получение списка записей GraphQl провайдером"
<query>
  <list>
    <graphql>
        query persons(filters: { $$filters }, page: $$page, size: $$limit, sort: { $$sorting }) {
           id
           name
           age
        }
    <graphql/>
  </list>

  <filters>
    <eq field-id="name">{ name: {eq: $$name} }</eq>
  </filters>

  <fields>
    <field id="id" sorting-expression="{ name: $$nameDir }" sorting-mapping="['nameDir']"/>

    <field id="name"/>

    <field id="age"/>
  </fields>
</query>
```

```xml title="Выполнение операции GraphQl провайдером"
<operation id="create">
  <invocation>
    <graphql>
      mutation {
         createPerson(name: $$name, age: $$age) {
            id
            name
            age
         }
      }
    </graphql>
  </invocation>
  <in>
    <field id="name"/>
    <field id="age"/>
  </in>
</operation>
```

#### Настройки GraphQl провайдера

Для подключения к backend сервису используется атрибут `endpoint`.
Вместо задания `endpoint` в каждом определении провайдера можно воспользоваться глобальной настройкой `n2o.engine.graphql.endpoint`.

Для обеспечения безопасного доступа к backend сервису необходимо использовать атрибут `access-token` или
глобальную настройку `n2o.engine.graphql.access-token`.

#### Экранирование строковых плейсхолдеров

Если значением плейсхолдера `$$` является строка, то значение оборачивается в кавычки, согласно синтаксису GraphQl.
```
$$name -> "Ann"
```
Для экранирования кавычек можно вместо `$$` плейсхолдера воспользоваться `$$$` плейсхолдером.
```
$$$name -> \"Ann\"
```

#### Обработка ошибок GraphQl провайдера

Для кастомизированной обработки ошибок результатов GraphQl сервера требуется включить её в реализации интерфейсов `OperationExceptionHandler`
 и `QueryExceptionHandler`.

```java title="Кастомный обработчик ошибок операций GraphQl сервера"
package com.example;

public class GraphQlOperationExceptionHandler implements OperationExceptionHandler {
    @Override
    public N2oException handle(CompiledObject.Operation o, DataSet data, Exception e) {
        ...
        // Обработка ошибки GraphQl сервера
        if (e instanceof N2oGraphQlException) {
            // Получение ответа, который вернул GraphQl сервер
            DataSet result = ((N2oGraphQlException) e).getResponse();
            DataList errors = (DataList) result.get("errors");
            ...
            // формирование сообщений валидации по ошибкам
            List<ValidationMessage> validationMessages = new ArrayList<>();
            for (Object obj : errors) {
                DataSet error = (DataSet) obj;
                String message = error.getString("message");
                String fieldId = error.getString("field");
                ...
                validationMessages.add(new ValidationMessage(message, fieldId, validationId));
            }
            return new N2oUserException("Ошибка валидации", null, validationMessages);
        }
        ...
    }
}
```

<Sandbox height={700} projectId="data_providers_graphql" />

### Java {#Java}

С помощью java провайдеров можно вызвать метод java класса.

Экземпляр класса можно получить с помощью IoC контейнера EJB или Spring.
Либо можно вызвать статический метод класса.

```xml title="Получение списка записей Java провайдером"
<query>
  <list>
    <java
      class="com.example.MyService"
      method="getList">
      <arguments>
        <argument
          type="criteria"
          class="com.example.MyCriteria"/>
      </arguments>
      <spring/>
    </java>
  </list>
  <fields>
    <field id="name" sorting="true"/>
  </fields>
</query>
```

```xml title="Выполнение операции Java провайдером"
<operation id="create">
  <invocation>
    <java class="com.example.MyService"
          method="create">
      <arguments>
        <argument
          type="entity"
          class="com.example.MyEntity"/>
      </arguments>
      <spring/>
    </java>
  </invocation>
  <in>
    <field id="firstName" mapping="[0].firstName"/>
    <field id="lastName" mapping="[0].lastName"/>
  </in>
</operation>
```

### MongoDB {#MongoDB}

MongoDB провайдер выполняет запросы к MongoDB базе данных.

```xml title="Получение списка записей Mongo DB провайдером"
<query>
    <list>
        <mongodb collection-name="person" operation="find"/>
    </list>
    <count>
        <mongodb collection-name="person" operation="countDocuments"/>
    </count>

    <filters>
        <eq field-id="id"/>
    </filters>

    <fields>
        <field id="id" sorting="true" domain="string">
        <field id="name" select-expression="name"/>
    </fields>
</query>
```

В теле фильтров необходимо использовать синтаксис построения запросов в mongodb.
В соответствии с официальной [документацией](https://docs.mongodb.com/manual/reference/operator/).
Используя плейсхолдер `#`, можно вставлять данные запроса(например значение фильтра)

```xml title="Пример"
<query>
    <list>
        <mongodb collection-name="person" operation="find"/>
    </list>

    <filters>
        <eq field-id="id">{ _id: new ObjectId('#id') }</eq>
        <like field-id="name" filter-id="nameLike" mapping="['nameLikeMap']">{ name: { $regex: '.*#nameLikeMap.*'}}</like>
        <likeStart field-id="name" filter-id="nameStart">{ name: {$regex: '#nameStart.*'}}</likeStart>
        <more field-id="birthday" filter-id="birthdayMore">{birthday: {$gte: new ISODate(#birthdayMore)}}</more>
        <less field-id="birthday" filter-id="birthdayLess">{birthday: {$lte: new ISODate(#birthdayLess)}}</less>
    </filters>

    <fields>
        <field id="id" mapping="['_id'].toString()" select-expression="_id"
                sorting="true" domain="string"/>
        <field id="name" select-expression="name" domain="string"
            sorting-mapping="['sortName']" sorting-expression="name :sortName"/>
        <field id="birthday" domain="localdate"/>
    </fields>
</query>
```

#### Автоматическая генерация для mongodb провайдера

В mongo db идентификатор записи всегда называется `_id`  и имеет тип `ObjectId`,
в N2O идентификатор записи должен называться `id` и иметь тип `string` или `integer`,
поэтому:

- `select-expression` для поля `id` преобразуется в `_id` с `mapping="['_id'].toString()"`
- для всех остальных полей `select-expression` преобразуется в `select-expression="id поля"`
- фильтр `eq` для поля `id` `<eq field-id="id"/>` преобразуется в `<eq field-id="id">{ _id: new ObjectId('#id') }</eq>`
фильтры других типов для поля id необходимо прописывать полностью.
Автоматическая генерация сработает только для типа eq.
- для других полей автоматическая генерация тела фильтра работает для всех типов.
Но необходимо учитывать, что она простая (для полей с типом дата необходимо писать самостоятельно, с учетом написания фильтров в mongodb).
- для поля `id` сортировка `sorting-expression` преобразуется в `sorting-expression="_id :idDirection"`
- для всех других полей, например `name`, `sorting-expression` преобразуется в `sorting-expression="name :nameDirection"`


```xml title="Пример"
<filters>
    <eq field-id="id" filter-id="id"/>
</filters>

<!-- Поле id -->
<fields>
    <field id="id" sorting="true" domain="string">
</fields>

<!-- трансформируется в -->
<filters>
    <eq filter-id="id">{ _id: new ObjectId('#id') }</eq>
</filters>

<field id="id" mapping="['_id'].toString()" selext-epression="_id" domain="string"
            sorting-expression="_id :idDirection"/>

<filters>
    <like field-id="name" filter-id="nameLike"/>
    <likeStart field-id="name" filter-id="nameStart"/>
</filters>

<!-- Поле name -->
<field id="name" domain="string" sorting="true"/>

<!-- трансформируется в -->
<filters>
    <like field-id="name" filter-id="nameLike">{ name: { $regex: '.*#nameLike.*'}}</like>
    <likeStart field=id="name" filter-id="nameStart">{ name: {$regex: '#nameStart.*'}}</likeStart>
</filters>

<field id="name" select-epression="name"
            sorting-expression="name :nameDirection" domain="string"/>

<!-- Для даты тело фильтров необходимо прописывать самостоятельно -->
<filters>
    <more field-id="birthday" filter-id="birthdayMore">{birthday: {$gte: new ISODate(#birthdayMore)}}</more>
    <less field-id="birthday" filter-id="birthdayLess">{birthday: {$lte: new ISODate(#birthdayLess)}}</less>
</filters>

<field id="birthday" domain="localdate"/>
```

```xml title="Выполнение операции Mongo DB провайдером"
<operation id="create">
  <invocation>
    <mongodb collection-name="person" operation="insertOne"/>
  </invocation>
  <in>
    <field id="firstName"/>
    <field id="lastName"/>
  </in>
</operation>
```

Доступны операции insertOne, updateOne, deleteOne, deleteMany, countDocuments.

<Sandbox height={300} projectId="data_providers_mongodb" />


### Типы данных {#Data_types}

Типы данных в N2O предназначены для правильной передачи значений от клиента
к провайдерам данных.

__*Типы данных*__

|Тип          |Описание                        |
|-------------|--------------------------------|
|string       |Строки                          |
|integer      |Целые числа                     |
|date         |Дата и время                    |
|localdate    |Локальная Дата                  |
|localdatetime|Локальная дата и время          |
|boolean      |Логический тип (true / false)   |
|object       |Объект с вложенными свойствами  |
|numeric      |Число с точкой без округлений   |
|long         |Большое целое число             |
|short        |Короткое целое число            |

Любой из перечисленных типов может образовывать списковый тип данных,
если добавить в конец квадратные скобки:

```
integer[]
```

Типы данных в XML элементах задаются ключевым словом `domain`.

```xml title="Тип integer в поле выборки"
<query>
  ...
  <fields>
    <field id="gender.id" domain="integer">
      ...
    </field>
  </fields>
</query>
```

```xml title="Тип integer в параметрах операции"
<operation>
  ...
  <in>
    <field id="gender.id" domain="integer"/>
  </in>
</operation>
```

### Биндинг полей {#Bindings}

Поле ввода, поле выборки и параметр операции связываются друг
с другом через идентификатор `id`:

```xml title="Поле виджета"
<input-text id="firstName"/>
```

```xml title="Поле выборки"
<field id="firstName"> ... </field>
```

```xml title="Параметр операции"
<field id="firstName"/>
```

Подобная связь называется биндингом.

<Sandbox height={200} projectId="data_binding_simple" />

#### Биндинг составных полей {#Binding_select}

Составные поля обычно используются в компонентах выбора одного значения из списка:

```xml
<input-select id="gender">
  ... <!-- Содержит id и name -->
</input-select>
```

В json представлении модель данных `gender` выглядит так:

```json
{
    "gender": {
      "id" : 1,
      "name" : "Мужской"
    }
}
```

Если мы хотим использовать только `id`, можно записать биндинг через "точку":

```xml
<field id="gender.id"/> <!-- 1 -->
```

А также можно использовать составное поле:

```xml
<reference id="gender">
    <field id="id"/><!-- 1 -->
</reference>
```

<Sandbox height={200} projectId="data_binding_select" />

#### Биндинг интервальных полей {#Binding_interval}

Интервальные поля — это поля, в которых можно задать начало и окончание:

```xml
<date-interval id="period">
  ... <!-- Содержит begin и end -->
</date-interval>
```

В json представлении модель данных `period` выглядит так:

```json
{
    "period": {
      "begin" : "01.01.2018 00:00",
      "end" : "31.12.2018 00:00"
    }
}
```

При передаче в два параметра нужно использовать окончание `.begin` и `.end`:

```xml
<field id="period.begin"/> <!-- 01.01.2018 00:00 -->
<field id="period.end"/> <!-- 31.12.2018 00:00 -->
```

Тот же кейс с использованием составного поля:

```xml
<reference id="period">
    <field id="begin"/><!-- 01.01.2018 00:00 -->
    <field id="end"/><!-- 31.12.2018 00:00 -->
</reference>
```

<Sandbox height={350} projectId="data_binding_interval" />

#### Биндинг полей множественного выбора {#Binding_multi}

Поля множественного выбора позволяют выбрать несколько значений из предложенных вариантов:

```xml
<select id="regions" type="multi">
  ...<!-- Содержит несколько регионов -->
</select>
```

Модель данных `regions` в json:

```json
{
    "regions": [
      {
        "id" : 1,
        "name" : "Адыгея"
      },
      {
        "id" : 16,
        "name" : "Татарстан"
      }
    ]
}
```

Чтобы в параметре операции собрать только идентификаторы `regions`
необходимо использовать "звёздочку":

```xml
<field id="regions*.id"/> <!-- [1,16] -->
```

Также можно использовать списковое поле:

```xml
<list id="regions">
    <field id="id"/><!-- [1,16] -->
</list>
```

### Маппинг данных в провайдерах {#Mapping}

Входные и выходные параметры провайдера могут несоответствовать полям ввода.
Для их приведения в соответствие используется атрибут `mapping`.
Выражение в `mapping` записывается на языке [SpEL](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions).

Провайдеры используют тип входных параметров: "ключ значение".

:::note

Java провайдеры в качестве альтернативы могут использовать тип входных параметров "массив значений".
Поэтому в маппинге java можно также обращаться по индексу аргумента, например, `[0]`, `[1].name`.

:::

#### Маппинг фильтров {#Mapping_filters}

##### Маппинг фильтров в sql, rest, graphql и mongodb

```xml title="Маппинг фильтров в sql провайдере"
<query>
  <list>
    <sql>SELECT t.first_name, t.gender_id FROM mytable t WHERE :filters</sql>
  </list>

  <filters>
  <!-- Маппинг определяет ключ "first_name" в который будет скопировано значение фильтра "firstName" -->
    <like field-id="firstName" mapping="['first_name']">
          t.first_name like '%'||:first_name||'%'
    </like>
  <!-- Маппинг определяет ключ "gender_id" в который будет скопирован id фильтра "gender" -->
    <eq field-id="gender.id" mapping="['gender_id']">
          t.gender_id = :gender_id
    </eq>
  <!-- Маппинг определяет ключ "genders" в который будет скопированы список id из фильтра "genders" -->
    <in field-id="gender.id" mapping="['genders']">
          t.gender_id in (:genders)
    </in>
  </filters>

  <fields>
    <field id="firstName"/>
    <field id="gender.id"/>
  </fields>
</query>
```

<Sandbox height={500} projectId="data_providers_sql_mapping" />

```xml title="Маппинг фильтров в rest провайдере"
<query>
  <list>
    <rest>/api/myentity/items?{filters}</rest>
  </list>

  <filters>
  <!-- Маппинг определяет ключ "gender_id" в который будет скопирован id фильтра "gender" -->
    <eq field-id="gender.id" mapping="['gender_id']">
          gender_id={gender_id}
    </eq>
  <!-- Маппинг определяет ключ "genders" в который будет скопированы список id из фильтра "genders" -->
    <in field-id="gender.id" mapping="['genders']">
          gender_id_in={genders}
    </in>
  <!-- Маппинг определяет ключ "first_name" в который будет скопировано значение фильтра "firstName" -->
    <like field-id="firstName" mapping="['first_name']">
          first_name_like={first_name}
    </like>
  </filters>

  <fields>
    <field id="firstName"/>
    <field id="gender.id"/>
  </fields>
</query>
```

<Sandbox height={500} projectId="data_providers_rest_mapping" />

```xml title="Маппинг фильтров в graphql провайдере"
<query>
  <list>
    <graphql filter-separator=", and:">
      query posts(filter: $$filters) {
        score
        completed
      }
    </graphql>
   </list>

  <!-- при указании тела в фильтре оно будет добавлено в $$filters плейсхолдер -->
  <filters>
    <eq field-id="score" filter-id="score">{ score: {gt: $$score} }</eq>
    <eq field-id="completed" filter-id="completed">{ completed: $$completed }</eq>
        ...
  </filters>

  <fields>
    <field id="score" mapping="['score']"/>
    <field id="completed" mapping="['completed']"/>
       ...
  </fields>
</query>
```

```xml title="Маппинг сортировки в mongodb провайдере"
<query>
  <list>
    <mongodb collection-name="user" operation="find"/>
  </list>
  <fields>
      <!-- Маппинг определяет ключ "sortUserAge" в который будет скопировано значение фильтра поля "userAge" -->
      <field id="userAge" domain="integer" sorting-mapping="['sortUserAge']"
            sorting-expression="age :sortUserAge"/>
  </fields>
</query>
```

#### Маппинг входных параметров операции {#Mapping_in}

##### Маппинг входных параметров операции sql

```xml title="Маппинг входных параметров в sql провайдере"
<operation>
  <invocation>
    <sql>INSERT INTO mytable (first_name, gender_id) VALUES (:first_name, :gender_id)</sql>
  </invocation>
  <in>
    <field id="name" mapping="['first_name']"/>
    <field id="gender.id" mapping="['gender_id']"/>
  </in>
</operation>
```

```xml title="Маппинг входных параметров в graphql провайдере"
<operation>
  <invocation>
    <graphql>mutation { create(score: $$user_score, completed: $$is_completed) {id score completed}</graphql>
  </invocation>
  <in>
    <field id="score" mapping="['user_score']"/>
    <field id="completed" mapping="['is_completed']"/>
  </in>
</operation>
```

##### Маппинг входных параметров операции rest

```text title="Запрос rest"
POST /api/myentity
```

```json title="Тело запроса"
{
    "firstName" : "John",
    "genderId" : 1
}
```

```xml title="Маппинг входных параметров в rest провайдере"
<operation>
  <invocation>
    <rest method="post">/api/myentity</rest>
  </invocation>
  <in>
    <field id="name" mapping="['firstName']"/>
    <field id="gender.id" mapping="['genderId']"/>
  </in>
</operation>
```

##### Маппинг входных параметров операции java

Для вызова метода java класса необходимо передать аргументы вызова в виде массива `Object[]`.
В java провайдере можно задать класс каждого аргумента.
Существует 3 типа аргументов: примитивы, сущности, критерии.

__*Типы аргументов java провайдера*__

|Тип      |Описание                                                                                               |
|---------|-------------------------------------------------------------------------------------------------------|
|primitive|Примитивные java классы: String, Integer, Boolean и т.п. Для них не нужно задавать атрибут `class`.    |
|entity   |Класс сущности. Для них не нужно задавать атрибут `class`, если в объекте задан атрибут `entity-class`.|
|criteria |Класс, содержащий фильтры, сортировки и паджинацию.                                                    |

###### Маппинг примитивов

Предположим у нас есть метод java класса с примитивным типом аргументов:

```java title="Метод java класса с примитивным типом аргументов"
package com.example;

class Calculator {
  public static Long sum(Long a, Long b) {
    return a + b;
  }
}
```

Чтобы смапить значение поля ввода в примитивный аргумент java метода, достаточно указать имя аргумента:

```xml title="Маппинг примитивов в java провайдере"
<operation>
  <invocation>
    <java class="com.example.Calculator" method="sum">
      <arguments>
        <argument type="primitive" name="arg1"/>
        <argument type="primitive" name="arg2"/>
      </arguments>
    </java>
  </invocation>
  <in>
    <field id="a" mapping="['arg1']"/>
    <field id="b" mapping="['arg2']"/>
  </in>
</operation>
```

:::note

Аргументы должны быть указаны в том же порядке, что и соответствующие аргументы java метода

:::

###### Маппинг сущности

```java title="Метод java класса с аргументом - сущностью"
@Service
class MyService {
  public Long create(MyEntity entity)  { ... }
}
```

```java title="java"
class MyEntity {
  private String name;
  private String surname;
  //getters and setters
}
```

Тип `entity` может быть задан только один раз среди всех аргументов.

```xml title="Маппинг сущности в java провайдере"
<operation>
  <invocation>
    <java class="com.example.MyService" method="create">
      <arguments>
        <argument type="entity" class="com.example.MyEntity"/>
      </arguments>
      <spring/>
    </java>
  </invocation>
  <in>
    <field id="firstName" mapping="[0].name"/>
    <field id="lastName" mapping="[0].surname"/>
  </in>
</operation>
```

###### Маппинг критериев

Критерии предназначены для передачи параметров фильтрации, сортировки и паджинации в java провайдер.
Как правило, фильтры задаются через поля класса, т.к. они уникальны для каждого случая.
А сортировка и паджинация задаются через базовый класс наследник.
N2O поддерживает несколько базовых классов критериев:

|Тип                                     |Описание                                                                  |
|----------------------------------------|--------------------------------------------------------------------------|
|org.springframework.data.domain.Pageable|Интерфейс библиотеки `spring-data` для задания паджинации                 |
|org.springframework.data.domain.Sort    |Класс библиотеки `spring-data` для задания сортировок                     |
|org.springframework.data.domain.Example |Интерфейс библиотеки `spring-data` для задания критериев по полям сущности|
|net.n2oapp.criteria.Criteria            |Класс библиотеки `criteria-api` для задания сортировок и паджинации       |

```java title="Метод java класса с аргументом - критерием"
@Service
class MyService {
  public List<MyEntity> getList(MyCriteria criteria)  { ... }
}
```

```java
class MyCriteria extends Criteria {
  private Date birtdayBefore;
  private Date birtdayAfter;
  //getters and setters
}
```

Тип `criteria` может быть задан только один раз среди всех аргументов.
Маппинга сортировки и паджинации не предусмотрено, они передаются через базовый класс наследник.


```xml title="Задание фильтров в java провайдере"
<query>
  <list>
    <java
      class="com.example.MyService"
      method="getList">
      <arguments>
        <argument
          type="criteria"
          class="com.example.MyCriteria"/>
      </arguments>
      <spring/>
    </java>
  </list>

  <filters>
    <more field-id="birthday" filter-id="birthdays.begin" mapping="[0].birthdayAfter"/>
    <less field-id="birthday" filter-id="birthdays.end" mapping="[0].birthdayBefore"/>
  </filters>

  <fields>
    <field id="birthday" sorting="true"/>
  </fields>
</query>
```

#### Маппинг результатов выборки {#Mapping_out}
Выборка возвращает список объектов при вызове через `<list>`, или один объект, при вызове через `<unique>`.
Задача маппинга — задать соответствие между свойством вернувшегося объекта и полем выборки.

##### Маппинг результатов выборки sql

```sql title="Sql запрос"
SELECT name as fname, surname as lname FROM mytable
```

```xml title="Маппинг результатов выборки sql провайдера"
<query>
  <list>
    <sql>SELECT name as fname, surname as lname FROM mytable</sql>
  </list>
  <count>
    <sql>SELECT count(*) FROM mytable</sql>
  </count>
  <fields>
    <field id="firstName" mapping="['fname']"/>
    <field id="lastName" mapping="['lname']"/>
  </fields>
</query>
```

##### Маппинг результатов выборки graphql

```json title="GraphQl запрос"
query persons() {name age}
```

```xml title="Маппинг результатов выборки sql провайдера"
<query>
  <list result-mapping="['data.persons']">
    <graphql>
      query persons() {
        name
        age
      }
    </graphql>
  </list>

  <fields>
    <field id="personName" mapping="['name']"/>
    <field id="personAge" mapping="['age']"/>
  </fields>
</query>
```

##### Маппинг результатов выборки rest

```text title="Запрос rest сервиса"
GET /api/myentity/items
```

```json title="Ответ rest сервиса"
{
  "data" : [
      {
        "name" : "John",
        "surname" : "Doe"
      },
      ...
  ],
  "cnt" : 123
}
```

```xml title="Маппинг результатов выборки из rest провайдера"
<query>
  <list>
    <rest
      result-mapping="data"
      count-mapping="cnt">/api/myentity/items</rest>
  </list>
  <fields>
    <field id="firstName" mapping="['name']"/>
    <field id="lastName" mapping="['surname']"/>
  </fields>
</query>
```

##### Маппинг результатов выборки java

```java title="Метод java класса, возвращающий Spring Data Page"
@Repository
interface MyRepository extends JpaRepository<MyEntity, Long> {
  Page<MyEntity> findAll();
}
```

```java
class MyEntity {
  private String name;
  private String surname;
  //getters and setters
}
```

```xml title="Маппинг результатов выборки в java провайдере"
<query>
  <list
    result-mapping="content"
    count-mapping="totalElements">
    <java
      class="com.example.MyRepository"
      method="findAll">
      <spring/>
    </java>
  </list>
  <fields>
    <field id="firstName" mapping="['name']"/>
    <field id="lastName" mapping="['surname']"/>
  </fields>
</query>
```

```xml title="Маппинг результатов выборки в mongodb провайдере"
<query>
  <list>
    <mongodb collection-name="user" operation="find"/>
  </list>
  <fields>
      <!-- маппинг определяет из какого поля результатов выборки из бд взять значение для userAge -->
      <field id="userAge" mapping="['age']" select-expression="age"
                domain="integer"/>
  </fields>
</query>
```

##### Маппинг вложенных полей

Маппинг вложенных полей должен быть прописан относительно маппинга родительского поля:

```json title="Ответ провайдера данных"

[
  {
    "id": 1001,
    "departments": [
      {
        "name": "department1",
        "manager": {
          "id": 1,
          "name": "manager1"
        }
      },
      {
        "name": "department2",
        "manager": {
          "id": 2,
          "name": "manager2"
        }
      }
    ]
  }
]
```

```xml title="Маппинг результатов"
<fields>
    <field id="orgId" mapping="['id']"/>

    <list id="orgDepartments" mapping="['departments']>
        <field id="depName" mapping="['name']"/>
        <reference id="depManager" mapping="['manager']">
            <field id="managerId" mapping="['id']/>
            <field id="managerName" mapping="['name']/>
        </reference>
    </list>
</fields>
```

:::note

При использовании вложенных полей также следует учитывать порядок маппинга и нормализации
дочернего и родительского поля, так как в процессе нормализации поля обрабатываемый объект может изменяться.
Порядок маппинга и нормализации сложных полей:
- Маппинг родительского поля
- Нормализация родительского поля
- Маппинг дочернего поля
- Нормализация родительского поля

:::

#### Маппинг результатов операции {#Mapping_result}

Чтобы вернуть данные от провайдера, после выполнения операции, используется элемент `<out>`:

##### Маппинг результатов sql

```xml title="Получение результата выполнения sql провайдера"
<operation>
  <invocation>
    <sql>INSERT INTO mytable (first_name, gender_id) VALUES (:first_name, :gender_id)</sql>
  </invocation>
  <out>
    <field id="id" mapping="[0]"/>
  </out>
</operation>
```

В примере результатом выполнения SQL запроса будет вставленная в таблицу запись.
Эту запись можно получить обратным маппингом, где 0 - номер колонки вставленной записи.

##### Маппинг результатов rest

```text title="Запрос rest"
POST /api/myentity
```

```json title="Ответ rest"
{
  "result" : 123
}
```

```xml title="Получение результата выполнения rest провайдера"
<operation>
  <invocation>
    <rest method="post">/api/myentity</rest>
  </invocation>
  <out>
    <field id="id" mapping="['result']"/>
  </out>
</operation>
```

##### Маппинг результатов mongodb

Операция insertOne возвращает всегда id, операции updateOne, deleteOne и deleteMany
не возвращают ничего, поэтому маппинг результатов имеет место только для insertOne.

```xml title="Пример"
<operation id="create">
    <invocation>
        <mongodb collection-name="user" operation="insertOne"/>
    </invocation>
    <in>
        <field id="name" mapping="['name']"/>
        <field id="age" mapping="['age']"/>
    </in>
    <out>
        <field id="id" mapping="#this"/>
    </out>
</operation>
```

#### Маппинг данных в Entity {#Mapping_entity}

При использовании java провайдеров объект и выборка чаще всего работают с одной и той же сущностью.
В N2O можно задать маппинг полей объекта на поля сущности в одном месте, и в дальнейшем не повторяться при выполнении операций, валидаций и выборок.

Для этого в объекте есть специальный атрибут `entity-class` и список полей `<fields>`:

```xml title="Определение entity класса в объекте"
<object
  entity-class="com.example.MyEntity">
  <fields>
    ...<!--Маппинг полей Entity-->
  </fields>
</object>
```

##### Маппинг простых полей сущности

Поля делятся на простые и составные.

Простые поля имеют примитивный тип данных (`Integer`, `String`, `Date` и т.п.)
Составные поля либо ссылаются на другие N2O объекты, либо имеют вложенные поля.


```java title="Класс сущности с простыми полями"
@Entity
class MyEntity {
  @Id
  @Column
  private Long id;
  @Column
  private Date birtDate;
  //getters and setters
}
```

```xml title="Маппинг простых полей"
<object entity-class="com.example.MyEntity">
  <fields>
    <!-- Простые поля -->
    <field id="id" domain="long" mapping="['id']"/>
    <field id="birthday" domain="date" mapping="['birthDate']"/>
  </fields>
</object>
```

Атрибут `id` задаёт поле виджета, атрибут `mapping` - поле сущности.

##### Маппинг полей @ManyToOne и @OneToOne

```java title="Класс сущности с @ManyToOne и @OneToOne"
@Entity
class MyEntity {
  @ManyToOne
  private Gender gender;
  @OneToOne
  private Address addr;
  //getters and setters
}
```

```xml title="Маппинг полей с @OneToOne"
<fields>
  <reference id="address"
    mapping="['addr']">
    <!-- Вложенные поля -->
    <field id="home" domain="string"/>
    <field id="work" domain="string"/>
  </reference>
</fields>
```

```xml title="Вариант с определением полей во внешнем файле"
<fields>
  <reference id="address"
    mapping="['addr']"
    object-id="address"/> <!-- Ссылка на объект address.object.xml -->
</fields>
```

```xml title="address.object.xml"
<!-- обратите внимание, что класс сущности может быть указан во внешнем файле -->
<object xmlns="http://n2oapp.net/framework/config/schema/object-4.0"
        entity-class="org.example.Address">
    <fields>
      <field id="home" domain="string"/>
      <field id="work" domain="string"/>
    </fields>
</object>
```

:::note

Описывать поля можно внутри составного поля (reference, list или set) или во внешнем файле.
Однако, если вы опишите поля в обоих местах, то более приоритетным будет вариант задания полей внутри составного поля.
Все поля будут взяты из него, а для полей присутствующих в обоих файлах (т.е. с совпадающим id)
будет произведено слияние в пользу текущего объекта.

:::

```xml title="Маппинг полей с @ManyToOne"
<fields>
  <reference id="sex"
    mapping="['gender']"
    required="true"
    object-id="gender"/>
</fields>
```

##### Маппинг полей @OneToMany и @ManyToMany

Поля объекта могут быть множественными.
Есть несколько типов множественности:

__*Типы множественности*__

|Тип |Описание       |
|----|---------------|
|list|Список значений|
|set |Набор значений |


```java title="Класс сущности с множественными полями"
@Entity
class MyEntity {
  @OneToMany
  private Set<Status> statuses;
  @ManyToMany
  private List<Address> addrs;
  //getters and setters
}
```

```xml title="Маппинг полей с @OneToMany и @ManyToMany"
<fields>
  <set id="statuses"
    mapping="['statuses']">
    <!--Вложенные поля-->
    <field id="id" domain="integer"/>
    <field id="name" domain="string"/>
  </set>
  <list id="addresses"
    mapping="['addrs']"
    object-id="address"/><!--Ссылка на объект-->
</fields>
```

##### Использование полей объекта

Если поле было задано в полях объекта, то при описании операций объекта не требуется определять
маппинг и прочие атрибуты, а также вложенную структуру. Достаточно задать только идентификаторы параметров.
В случае, если поле будет присутствовать в обоих местах, то будет произведено слияние с приоритетом в пользу поля в операции.

```java
@Service
class MyService {
  MyEntity create(MyEntity entity) { ... }
}
```

```xml title="Использование полей объекта в операции"
<object entity-class="com.example.Employee">
  <!-- Маппинг и структура полей сущности -->
  <fields>
    <field id="name" mapping="['name']" normalize="..."/>
    <reference id="org" mapping="['organization']" object-id="org"/>
    <list id="departments" entity-class="com.example.Department">
      <field id="id"/>
      <field id="name"/>
    </list>
  </fields>

  <operations>
    <operation>
      <invocation>
        <java method="create">
          <arguments>
            <argument type="entity"/>
          </arguments>
          <spring/>
        </java>
      </invocation>
      <in>
        <!-- Перечисление только нужных полей -->
        <!-- Не нужно задавать ни структуру, ни атрибуты -->
        <field id="name"/>
        <reference id="org"/>
        <list id="departments"/>
      </in>
      <out>
        <field id="id"/>
      </out>
    </operation>
  </operations>
</object>
```

[Пример](https://sandbox.n2oapp.net/new/data/object/nesting_object_fields_for_args_provider)
